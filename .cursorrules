
## Frontend (Flutter) `.cursorrules`

```md
---
description: "Gu√≠a de desarrollo Frontend (Flutter) para el MVP de Corral X"
alwaysApply: true
---

## REGLAS FUNDAMENTALES DE COLABORACI√ìN

**IMPORTANTE: El usuario es el l√≠der del proyecto. El asistente debe:**

1. **SIEMPRE PREGUNTAR** antes de realizar cualquier acci√≥n
2. **NUNCA crear archivos nuevos** si es para editar c√≥digo existente
3. **SIEMPRE sugerir detalladamente** qu√© hacer y esperar aprobaci√≥n
4. **NUNCA hacer push a git** sin orden expl√≠cita del usuario
5. **NUNCA hacer merge a git** sin orden expl√≠cita del usuario
6. **El usuario tiene el mando** - el asistente sugiere, el usuario decide

**Flujo de trabajo:**
- Asistente: "Sugiero hacer X, ¬øquieres que proceda?"
- Usuario: "S√≠, hazlo" o "No, mejor Y"
- Asistente: Ejecuta solo lo aprobado

**CR√çTICO - Control de Git:**
- ‚ùå **NUNCA hacer push autom√°ticamente** - Solo cuando el usuario lo ordene expl√≠citamente
- ‚ùå **NUNCA hacer merge autom√°ticamente** - Solo cuando el usuario lo ordene expl√≠citamente
- ‚úÖ **Solo hacer commits locales** cuando se realicen cambios
- ‚úÖ **Esperar aprobaci√≥n del usuario** antes de cualquier push o merge
- ‚úÖ **El usuario prueba primero** y da la orden cuando est√° seguro

**El asistente debe:**
- Hacer los cambios solicitados
- Hacer commit local (si es necesario)
- Informar qu√© se cambi√≥
- **ESPERAR** la orden expl√≠cita del usuario para push/merge

---

## Arquitectura Modular y Convenciones (Flutter)
- Organizar el c√≥digo en la carpeta `lib/` usando una arquitectura modular por features:
  - **`lib/config/`** ‚Äì Configuraci√≥n central (app_config.dart, auth_utils.dart, corral_x_theme.dart, user_provider.dart).
  - **`lib/shared/`** ‚Äì Servicios y widgets compartidos entre m√≥dulos.
  - **`lib/auth/`** ‚Äì M√≥dulo de autenticaci√≥n (screens/, services/, models/, widgets/).
  - **`lib/onboarding/`** ‚Äì M√≥dulo de onboarding (screens/, services/, models/, widgets/).
  - **`lib/products/`** ‚Äì M√≥dulo de productos/marketplace (screens/, services/, models/, widgets/).
  - **`lib/chat/`** ‚Äì M√≥dulo de chat (screens/, services/, models/, widgets/).
  - **`lib/favorites/`** ‚Äì M√≥dulo de favoritos (screens/, services/, models/, widgets/).
  - **`lib/profiles/`** ‚Äì M√≥dulo de perfiles (screens/, services/, models/, widgets/).
  - Cada m√≥dulo contiene: `models/`, `screens/`, `services/`, `widgets/` espec√≠ficos de esa funcionalidad.
- Seguir convenciones de nombrado de Dart/Flutter:
  - Nombres de archivos y directorios en min√∫scula y con guiones bajos (snake_case), sin espacios ni may√∫sculas:contentReference[oaicite:0]{index=0}.
  - Nombres de clases en PascalCase (capitalizando cada palabra, e.j. class `ListingProvider`).
  - Nombres de variables y m√©todos en lowerCamelCase.
  - Evitar nombres muy largos; preferir claridad y brevedad (ej. `ListingsScreen` mejor que `AllListingsListScreen`).
- Mantener una estructura limpia: una pantalla por archivo; widgets auxiliares en archivos separados si son lo suficientemente complejos. Se puede agrupar sub-componentes dentro de carpetas por pantalla (ej. `screens/listing_detail/` con `listing_detail_screen.dart` y widgets relacionados).
- Incluir comentarios y documentaci√≥n en el c√≥digo para facilitar la lectura por el equipo (usar `///` para documentar clases y m√©todos p√∫blicos).
- Usar el patr√≥n **Provider** para gesti√≥n de estado por simplicidad en el MVP (evitar patrones m√°s complejos como BLoC o Riverpod a menos que el equipo los prefiera).

## M√≥dulo de KYC / Verificaci√≥n de Identidad (MVP)

### Objetivo
- Implementar un flujo de verificaci√≥n de identidad tipo Binance pero **adaptado al MVP** y **obligatorio** para todos los usuarios:
  - Verificaci√≥n de **documento de identidad** (foto frontal, opci√≥n dorso).
  - Verificaci√≥n de **rostro** (selfie).
  - **Selfie sosteniendo el documento** (prueba adicional de v√≠nculo persona‚Äìdocumento).
- En el MVP se prioriza la **C√©dula de Identidad venezolana (CI, formato V-/E-)** como documento principal de persona.
- La verificaci√≥n KYC tambi√©n considera los datos fiscales de la hacienda (RIF) capturados en `OnboardingPage2` para asegurar coherencia persona‚Äìnegocio.
- Sin tablas redundantes: el estado KYC y metadatos m√≠nimos se reflejan en el **perfil del usuario**, no en nuevas tablas complejas.
- El flujo de KYC se integra **dentro del onboarding inicial** y es un paso obligatorio antes de entrar al `MainRouter`.

### Alcance del MVP Frontend
- El m√≥dulo KYC tendr√°:
  - Reglas de negocio y estado reflejados v√≠a `kyc_status` proveniente del backend.
  - Pantallas integradas al `OnboardingScreen` actual (antes de finalizar).
  - Bloqueo suave de ciertas acciones (por ejemplo, publicar) si el KYC no est√° verificado, con mensajes claros.

### Ubicaci√≥n y organizaci√≥n de c√≥digo
- **L√≥gica y comunicaci√≥n API KYC (reutilizable):**
  - `lib/kyc/services/kyc_service.dart`
    - Encapsula llamadas HTTP a los endpoints `/api/kyc/*`.
  - `lib/kyc/providers/kyc_provider.dart`
    - Maneja el estado del KYC (status, flags, errors, loading).
  - `lib/kyc/widgets/`
    - Widgets reutilizables: overlays de c√°mara, headers de pasos, indicadores de estado.
- **Pantallas de KYC dentro del onboarding (flujo inicial):**
  - `lib/onboarding/screens/kyc_onboarding_intro_page.dart`
  - `lib/onboarding/screens/kyc_onboarding_document_page.dart`
  - `lib/onboarding/screens/kyc_onboarding_selfie_page.dart`
  - `lib/onboarding/screens/kyc_onboarding_selfie_with_doc_page.dart`
  - Estas vistas se integran en la lista `onboardingPages` de `OnboardingScreen` y usan `KycProvider`/`KycService` para hablar con el backend.

### Estados y contrato con backend
- `KycProvider` expone al menos:
  - `String kycStatus`:
    - Valores esperados: `no_verified`, `pending`, `verified`, `rejected`.
  - `bool hasDocument`, `hasSelfie`, `hasSelfieWithDoc`.
  - `String? rejectionReason`.
  - `bool isLoading`, `isUploading`.
  - `String? errorMessage`.
- M√©todos principales de `KycProvider`:
  - `Future<void> loadStatus()`
  - `Future<void> startKyc({String? documentType, String? countryCode})`
  - `Future<void> submitDocument({required XFile front, XFile? back, required String documentType, String? documentNumber, String? countryCode})`
  - `Future<void> submitSelfie(XFile selfie)`
  - `Future<void> submitSelfieWithDoc(XFile selfieWithDoc)`
- `KycService` implementa las llamadas HTTP/multipart reales hacia:
  - `GET /api/kyc/status`
  - `POST /api/kyc/start`
  - `POST /api/kyc/upload-document`
  - `POST /api/kyc/upload-selfie`
  - `POST /api/kyc/upload-selfie-with-doc`

### Integraci√≥n con Onboarding (`lib/onboarding/screens/onboarding_screen.dart`)
- `OnboardingScreen` ya usa un `PageView` con p√°ginas:
  - `WelcomePage`
  - `OnboardingPage1` (datos personales: CI, tel√©fono, direcci√≥n, ubicaci√≥n‚Ä¶)
  - `OnboardingPage2` (datos de hacienda: nombre, raz√≥n social, RIF, descripci√≥n‚Ä¶)
  - `OnboardingPage3` (pantalla final ‚Äú¬°Todo listo!‚Äù)
- Para el KYC MVP se debe:
  - Insertar las p√°ginas KYC **entre la p√°gina de hacienda y la p√°gina final**, por ejemplo:
    - `WelcomePage`
    - `OnboardingPage1`
    - `OnboardingPage2`
    - `KycOnboardingIntroPage`
    - `KycOnboardingDocumentPage`
    - `KycOnboardingSelfiePage`
    - `KycOnboardingSelfieWithDocPage`
    - `OnboardingPage3`
  - Reutilizar la infraestructura actual:
    - `onboardingPages` se expande con las nuevas vistas.
    - `_handleNext()` sigue siendo el √∫nico punto de avance, y delega en `_saveCurrentPageData()` para validar/guardar cada paso.
    - `_completeOnboarding()` se ejecuta **solo despu√©s** de pasar los pasos de KYC y de que el backend acepte la creaci√≥n de perfil + tel√©fono + direcci√≥n + hacienda (incluyendo RIF).
- Reglas UX del onboarding con KYC:
  - No permitir avanzar de una p√°gina KYC si no se ha cargado la imagen requerida (mostrar mensaje claro).
  - Mostrar estados simples (por ejemplo, check visual cuando un paso KYC est√© completado).
  - Los errores provenientes del backend (ej. documento ilegible, inconsistencia b√°sica) se mostrar√°n como `SnackBar` o texto rojo, y mantendr√°n al usuario en la misma p√°gina.

### Integraci√≥n con `UserProvider` y `ProfileScreen`
- `UserProvider`:
  - Debe almacenar `kycStatus` cuando llame a `getUserDetails()`.
  - Expone un getter tipo `String get userKycStatus`.
- `ProfileScreen`:
  - Secci√≥n ‚ÄúVerificaci√≥n de identidad‚Äù con:
    - Badge seg√∫n `kycStatus`:
      - `No verificado`, `Pendiente`, `Verificado`, `Rechazado`.
    - Botones:
      - `No verificado` o `Rechazado`: bot√≥n ‚ÄúVerificar identidad‚Äù ‚Üí flujo KYC (puede reutilizar p√°ginas de onboarding, o versiones simplificadas reusando los mismos widgets de `lib/kyc/widgets/`).
      - `Pendiente`: bot√≥n ‚ÄúVer estado KYC‚Äù.
  - Esta entrada desde perfil es secundaria en el MVP (completar KYC desde onboarding es prioridad), pero se debe dejar preparada la estructura para que no se duplique c√≥digo.

### Reglas de negocio (frontend) relacionadas con KYC
- **Publicar productos**:
  - Adem√°s de validar perfil + hacienda completos (`ProfileService.checkCompleteness()`), se debe revisar `kycStatus`.
  - Si `kycStatus != 'verified'`:
    - Mostrar `AlertDialog` explicando que debe completar la verificaci√≥n de identidad.
    - Ofrecer bot√≥n ‚ÄúIr a verificaci√≥n‚Äù que lleve a la pantalla KYC adecuada (o a un resumen con bot√≥n para iniciar/reintentar).
    - No permitir cambiar la pesta√±a a `CreateScreen` en el `BottomNavigationBar`.
- **Mensajes claros para el usuario**:
  - El frontend nunca habla de ‚Äúcompliance‚Äù o t√©rminos t√©cnicos; usar texto claro tipo:
    - ‚ÄúPara publicar productos necesitas verificar tu identidad (selfie + documento).‚Äù
    - ‚ÄúTu verificaci√≥n est√° en revisi√≥n. Te avisaremos cuando se complete.‚Äù
    - ‚ÄúTu verificaci√≥n fue rechazada. Revisa el motivo y vuelve a intentarlo.‚Äù

### Evoluci√≥n: KYC 100% autom√°tico con IA (plan)
- El objetivo del proyecto es que la verificaci√≥n KYC sea **totalmente autom√°tica**, sin revisi√≥n manual en el flujo normal del usuario:
  - El frontend captura CI, RIF, selfie y selfie con documento.
  - El backend consolida los datos estructurados (OCR CI/RIF + metadatos + paths de im√°genes) y decide `kyc_status`.
- Desde frontend:
  - No se implementan pantallas de revisi√≥n manual; solo se consumen `kyc_status`, `kyc_rejection_reason` y flags (`has_document`, `has_selfie`, etc.).
  - Cualquier evaluaci√≥n ‚Äúinteligente‚Äù (IA) se hace **solo en backend** y se expone como resultado ya procesado.
- IA y restricciones de servicios:
  - La √∫nica IA externa planificada para KYC es **Gemini**, consumida por el backend (no se a√±aden servicios pagos extra como Vision/Rekognition).
  - El frontend nunca env√≠a im√°genes crudas a Gemini; solo usa los estados/decisiones que devuelve la API del backend (`kyc_status`, motivos, recomendaciones).

## Flujo de pedidos y entrega (sin pagos digitales)
- La app **coordina** la operaci√≥n pero **NO procesa pagos**. El intercambio econ√≥mico ocurre cuando comprador y vendedor se encuentran f√≠sicamente.
- Secuencia completa (documentada a detalle en `CICLO_COMPLETO_LOGIC_DETALLADA.md`):
  1. Negociaci√≥n en `ChatScreen`.
  2. Comprador confirma compra (nuevo di√°logo con cantidad + precio + m√©todo de delivery).
  3. Se crea `Order` (`status='pending'`).
  4. Vendedor acepta/rechaza desde `OrderDetailScreen`.
  5. Al aceptar se genera autom√°ticamente un **comprobante de venta** (`ReceiptScreen`) que funciona como contrato operativo.
  6. Se ejecuta el m√©todo de delivery acordado (4 opciones descritas abajo).
  7. Comprador confirma recogida (`markAsDelivered`), luego ambos califican (`MutualReviewScreen`), `Order` pasa a `completed`.
- **Opciones de delivery** (capturadas en el formulario y mostradas en el comprobante):
  1. `buyer_transport`: el comprador lleva su transporte (finca u otro punto).
  2. `seller_transport`: el vendedor entrega en la direcci√≥n del comprador.
  3. `external_delivery`: servicio de terceros (se registra proveedor y costo).
  4. `corralx_delivery`: log√≠stica interna de CorralX (costo/seguimiento propios).
- El comprobante debe incluir siempre: datos del vendedor (nombre, finca, direcci√≥n, contacto), datos del comprador, detalle del producto, m√©todo de delivery, direcciones, fecha esperada y notas. Tambi√©n se debe indicar expl√≠citamente que el pago se realiza fuera de la app.
- A√±adir opcionalmente controles futuros en UI (mostrar estado ‚ÄúConfirmaci√≥n pendiente del vendedor‚Äù, permitir subir evidencias, abrir disputas) aunque la primera entrega del MVP solo requiere la confirmaci√≥n del comprador.

## Nuevos m√≥dulos/screen obligatorios
- `OrderProvider` y `OrderService`: encapsulan llamadas a `/api/orders`, `/api/orders/{id}/receipt`, `/api/orders/{id}/review`, etc. Deben residir en `lib/orders/` o `lib/shared/` (seg√∫n convenga) y exponer m√©todos m√≠nimos: `createOrder`, `acceptOrder`, `rejectOrder`, `markAsDelivered`, `getReceipt`, `submitReview`, `loadOrders`.
- `MyOrdersScreen`: lista de pedidos con Tabs (‚ÄúComo Comprador‚Äù, ‚ÄúComo Vendedor‚Äù), estados, filtros y accesos a detalle/comprobante/calificaciones.
- `OrderDetailScreen`: muestra el pedido, botones contextuales (aceptar/rechazar, confirmar recogida, calificar) y acceso a `ReceiptScreen`.
- `ReceiptScreen`: consume `Order.receipt_data`, renderiza el comprobante y ofrece acciones ‚ÄúCompartir‚Äù y ‚ÄúDescargar PDF‚Äù.
- `MutualReviewScreen`: formulario de calificaciones (producto + vendedor para compradores, comprador para vendedores). Debe validarse que solo se env√≠e una vez por pedido.
- `ChatScreen`: mantener el flujo actual e incorporar el FAB/bot√≥n ‚ÄúConfirmar compra‚Äù (solo visible si no existe un pedido abierto para esa conversaci√≥n). El di√°logo debe construir la carga √∫til completa para `POST /api/orders` seg√∫n la selecci√≥n de delivery.

## Servicios y Comunicaci√≥n con la API
- Centralizar las llamadas HTTP en clases de servicio bajo `lib/services/`:
  - Crear un `ApiService` base que use paquetes como `http` (o `dio` si se prefiere) para manejar peticiones. Este servicio puede gestionar el token de autenticaci√≥n globalmente (p.ej., adjuntar header `Authorization: Bearer <token>` a cada request tras login).
  - Servicios espec√≠ficos por recurso: ej. un `ListingService` con m√©todos para la l√≥gica de publicaciones: `fetchListings({filters})`, `getListingDetail(id)`, `createListing(data)`, `updateListing(id, data)`, `deleteListing(id)`. Cada m√©todo realiza la petici√≥n REST correspondiente y retorna datos procesados (decodificados a Map o convertidos a modelo).
  - **AuthService:** m√©todos `login(email, pass)`, `register(datos)`, `logout()` que llaman a las rutas `/api/login`, `/api/register` y gestionan el almacenamiento seguro del token (usando `flutter_secure_storage` para el JWT, por ejemplo).
  - **ChatService:** m√©todos para obtener conversaciones (`getConversations()` -> GET `/api/chat/conversations`), obtener mensajes de un chat (`getMessages(convId)` -> GET `/api/chat/conversations/{id}/messages`) y enviar mensaje (`sendMessage(convId, text)` -> POST `/api/chat/conversations/{id}/messages`), marcar como le√≠do (`markAsRead(convId)` -> POST `/api/chat/conversations/{id}/read`), crear conversaci√≥n (`createConversation(participantId)` -> POST `/api/chat/conversations`), eliminar conversaci√≥n (`deleteConversation(convId)` -> DELETE `/api/chat/conversations/{id}`).
  - **WebSocketService:** manejo de conexi√≥n WebSocket para chat en tiempo real, incluyendo:
    - `connect()` - Establecer conexi√≥n persistente con el servidor WebSocket
    - `disconnect()` - Cerrar conexi√≥n cuando app va a background o cierra
    - `onMessage(callback)` - Escuchar mensajes entrantes en tiempo real
    - `sendMessage(message)` - Enviar mensaje a trav√©s de WebSocket
    - `onTyping(callback)` - Detectar cuando otro usuario est√° escribiendo
    - `reconnect()` - Reconexi√≥n autom√°tica con backoff exponencial (1s, 2s, 4s, 8s, max 30s)
    - `heartbeat()` - Keep-alive cada 30 segundos para mantener conexi√≥n
    - Manejo de estados: `connecting`, `connected`, `disconnected`, `reconnecting`, `error`
    - Cola de mensajes pendientes cuando hay p√©rdida temporal de conexi√≥n
    - Indicadores visuales de estado de conexi√≥n en la UI
  - **NotificationService:** integraci√≥n con Firebase Cloud Messaging (FCM) para notificaciones push:
    - `initialize()` - Configurar FCM al iniciar la app
    - `requestPermission()` - Solicitar permisos de notificaciones al usuario
    - `getToken()` - Obtener device token para env√≠o de notificaciones
    - `onMessageReceived(callback)` - Manejar notificaciones recibidas (foreground y background)
    - `showLocalNotification(title, body)` - Mostrar notificaci√≥n local
    - `navigateToChat(conversationId)` - Navegar a chat espec√≠fico al tocar notificaci√≥n
    - `updateBadgeCount(count)` - Actualizar badge de mensajes no le√≠dos
    - Notificaciones silenciosas cuando app est√° abierta, sonido/vibraci√≥n cuando est√° cerrada
    - Deep linking para abrir conversaci√≥n espec√≠fica desde notificaci√≥n
  - Manejar errores HTTP en estos servicios: si la respuesta tiene c√≥digo de error, interpretar y lanzar excepciones o retornar valores de error para que la UI pueda reaccionar. Ej.: 401 -> lanzar error de autenticaci√≥n (frontend redirige a login), 422 -> devolver lista de errores de validaci√≥n para mostrarlos en el formulario.
- Parsear las respuestas JSON en modelos Dart o mapas:
  - Si se definieron clases de modelo (con factory `fromJson`), usarlas para convertir las respuestas. Ej: `Listing.fromJson(json)` por cada elemento en la lista de listings.
  - Enviar datos al backend en formato JSON con `http.post/put` y encabezado `Content-Type: application/json`. Usar `jsonEncode` en los cuerpos, asegurando que los nombres de campos coinciden con los esperados por el backend.
- Implementar un mecanismo global de autenticaci√≥n:
  - Guardar el token del usuario (y posiblemente el objeto User) en un provider global (`AuthProvider`) al hacer login.
  - Adjuntar el token en **ApiService** en cada llamada (p.ej., configurar `http.Client` con un interceptor o a√±adir header en cada m√©todo de servicio).
  - El AuthProvider maneja verificar si hay token guardado al iniciar la app (auto-login) y la l√≥gica de cerrar sesi√≥n (borrar token de storage, limpiar estados).
- Manejar subida de archivos/im√°genes si aplica:
  - Para adjuntar foto en una publicaci√≥n o actualizar avatar, usar `ImagePicker` (para obtener la imagen local) y luego `http.MultipartRequest` o m√©todos de `dio` para enviar la imagen al backend (ya sea a un endpoint dedicado o incluido en el payload de creaci√≥n). El servicio correspondiente debe manejar la construcci√≥n de la petici√≥n multipart.
  - Asegurarse que el backend devuelva la URL o path de la imagen guardada, y actualizar el modelo (Listing o User) con ese dato para futuras solicitudes.
- Evitar l√≥gica de negocio compleja en las pantallas: delegar a los servicios y providers. Las pantallas solo invocan m√©todos de provider o service, esperan los resultados (futures) y muestran feedback (spinners, mensajes de error).

## Gesti√≥n de Estado (Provider) y Flujos de Datos
- Utilizar el paquete **provider** para manejo sencillo del estado:
  - En `main.dart`, envolver la app con `MultiProvider` registrando los ChangeNotifiers necesarios: `AuthProvider`, `ListingProvider`, `ChatProvider`, etc.
  - **AuthProvider:** mantiene info del usuario actual (usuario logueado) y su token. Expone propiedades como `isAuthenticated` y `currentUser`. Maneja `login()`/`register()`/`logout()` llamando a AuthService y notificando listeners en consecuencia.
  - **ListingProvider:** maneja la lista de publicaciones y las operaciones CRUD relacionadas.
    - Tiene una lista `listings` (inicialmente vac√≠a) y quiz√°s `Listing? selectedListing` para detalle. 
    - M√©todos: `fetchListings([filters])` llama a ListingService.fetchListings; al obtener datos, rellena `listings` y hace `notifyListeners()`. Opcionalmente recibe filtros de b√∫squeda y los pasa a la API.
    - `getListingDetail(id)` podr√≠a obtener detalle de una publicaci√≥n (o aprovechar los datos ya cargados en `listings`). 
    - `createListing(datos)` llama ListingService.createListing; si √©xito, a√±ade la nueva publicaci√≥n a `listings` y notifica. 
    - `updateListing(id, datos)` actualiza tanto v√≠a API como localmente en la lista (reemplazando el objeto modificado).
    - `deleteListing(id)` env√≠a DELETE a API y si √©xito, remueve la publicaci√≥n de `listings`.
    - Tambi√©n maneja filtros locales de ser necesario (aunque es preferible delegar filtrado al backend enviando query params).
  - **ChatProvider:** maneja las conversaciones y mensajes del chat con integraci√≥n completa de WebSocket y notificaciones:
    - **Estado:**
      - `List<Conversation> conversations` - Lista de todas las conversaciones del usuario
      - `Map<String, List<Message>> messagesByConv` - Mensajes organizados por conversaci√≥n
      - `int unreadCount` - Contador total de mensajes no le√≠dos (para badge)
      - `bool isLoading` - Indicador de carga inicial
      - `String? errorMessage` - Mensaje de error si falla alguna operaci√≥n
      - `WebSocketConnectionState connectionState` - Estado de conexi√≥n WebSocket (connecting/connected/disconnected/reconnecting)
      - `Map<String, bool> typingUsers` - Usuarios que est√°n escribiendo en cada conversaci√≥n
    - **M√©todos principales:**
      - `loadConversations()` - Obtiene lista de conversaciones v√≠a HTTP (ChatService.getConversations), ordena por fecha del √∫ltimo mensaje, actualiza `unreadCount` sumando no le√≠dos de todas las conversaciones
      - `openConversation(userId, {productId})` - Crea o abre conversaci√≥n existente: primero verifica si existe conversaci√≥n con ese usuario (busca en `conversations`), si no existe llama a ChatService.createConversation, luego carga mensajes con `loadMessages(convId)`, marca la conversaci√≥n como activa
      - `loadMessages(convId)` - Carga historial de mensajes v√≠a HTTP (ChatService.getMessages), guarda en `messagesByConv[convId]`, auto-marca como le√≠do si usuario entra a la pantalla de chat
      - `sendMessage(convId, text)` - Env√≠a mensaje con feedback optimista:
        1. Agrega mensaje localmente con estado "sending" (feedback optimista)
        2. Env√≠a a trav√©s de WebSocketService (si conectado) o ChatService (fallback HTTP)
        3. Al recibir confirmaci√≥n, actualiza estado a "sent" y asigna ID real del servidor
        4. Si falla, marca mensaje con estado "failed" y bot√≥n de reintento
        5. Actualiza `lastMessage` en la conversaci√≥n correspondiente
      - `markAsRead(convId)` - Marca mensajes como le√≠dos v√≠a HTTP (ChatService.markAsRead), actualiza contador local `unreadCount`, actualiza estado de mensajes en `messagesByConv[convId]` a "read"
      - `deleteConversation(convId)` - Elimina conversaci√≥n con confirmaci√≥n del usuario, llama ChatService.deleteConversation, remueve de `conversations` localmente
    - **Integraci√≥n WebSocket:**
      - En `init()` del provider, conecta WebSocketService y registra callbacks
      - `WebSocketService.onMessage((message) {...})` - Al recibir mensaje nuevo: agrega a `messagesByConv`, actualiza `lastMessage` de conversaci√≥n, incrementa `unreadCount` si no est√° en esa conversaci√≥n, dispara notificaci√≥n local si app en foreground
      - `WebSocketService.onTyping((convId, userId, isTyping) {...})` - Actualiza `typingUsers[convId]` para mostrar "Usuario est√° escribiendo..."
      - `WebSocketService.onConnectionChange((state) {...})` - Actualiza `connectionState` para mostrar indicador visual en UI
      - Si WebSocket se desconecta, mantiene cola de mensajes pendientes y los env√≠a cuando reconecte
    - **Integraci√≥n NotificationService:**
      - En `init()`, configura callback de NotificationService para manejar tap en notificaci√≥n
      - `NotificationService.onNotificationTap((convId) {...})` - Navega a ChatScreen con esa conversaci√≥n
      - Cuando llega mensaje nuevo y usuario NO est√° en esa conversaci√≥n, trigger notificaci√≥n push
  - Los providers deben notificar a la UI para refrescar: usar `notifyListeners()` tras cambios. En la UI, usar `Consumer<...>` o `context.watch()` para reconstruir widgets reactivos cuando cambie el estado.
- Manejar estados de carga y error en los providers:
  - Por ejemplo, `ListingProvider` puede tener `bool isLoading` mientras carga publicaciones, y `String? errorMessage` si falla la carga. La UI (MarketplaceScreen) debe revisar estos para mostrar un `CircularProgressIndicator` cuando `isLoading=true` o un mensaje de error si `errorMessage != null`.
  - Similar para operaciones de env√≠o: se puede tener `isSubmitting` en formularios (evita doble submit) y `validationErrors` para mostrar errores espec√≠ficos de campos.
  - `ChatProvider` podr√≠a tener indicadores `isSending` para deshabilitar el campo de texto mientras se env√≠a un mensaje, `isConnected` para mostrar el estado de la conexi√≥n WebSocket, y manejar una cola de mensajes pendientes si se quiere extender.

## Dise√±o de Pantallas y Navegaci√≥n
- Implementar una navegaci√≥n acorde a los flujos principales (se puede usar `Navigator.push`/`pop` o rutas nombradas con `onGenerateRoute`). Una barra de navegaci√≥n inferior puede facilitar el acceso a secciones: Marketplace, Chats, Perfil, etc.
- **Pantalla Marketplace (Listado Principal):**
  - Muestra la lista de publicaciones en venta utilizando `ListingProvider.listings`. Usar un `ListView.builder` con un widget personalizado (`ListingCard`) para cada item, mostrando foto principal, tipo/raza, ubicaci√≥n y posiblemente precio o edad.
  - En la parte superior, incluir barra de b√∫squeda y filtros (por raza, tipo, ubicaci√≥n). Al aplicar filtros, llamar `fetchListings` con par√°metros o filtrar la lista existente y notificar.
  - Implementar pull-to-refresh (usando `RefreshIndicator`) que dispare `fetchListings()` nuevamente desde el backend.
  - Al tocar una publicaci√≥n, navegar a la pantalla de detalle de publicaci√≥n (pasando el ID o el objeto Listing).
- **Pantalla Detalle de Publicaci√≥n:**
  - Muestra la informaci√≥n completa de la publicaci√≥n seleccionada: varias im√°genes (Carousel o PageView), descripci√≥n extensa, detalles (edad, cantidad, ubicaci√≥n espec√≠fica, fecha publicaci√≥n), y datos del vendedor (nombre comercial, ubicaci√≥n general, rating, verificado con insignia).
  - Botones contextuales:
    - **Contactar / Mensaje:** visible para usuarios que no son due√±os. Al pulsar, iniciar o abrir chat con el vendedor: llamar a `ChatProvider.openConversation(sellerId)` (posiblemente pasando tambi√©n listingId para contexto inicial) y navegar a ChatScreen.
    - **Editar / Eliminar:** visibles solo si el usuario actual es el propietario de la publicaci√≥n. *Editar* navega a la pantalla de formulario de publicaci√≥n con los datos precargados. *Eliminar* muestra confirmaci√≥n y si se acepta, llama `ListingProvider.deleteListing` y al √©xito hace `Navigator.pop()` (y quiz√° refresca la lista).
  - Mostrar m√©tricas: n√∫mero de vistas de la publicaci√≥n, cu√°ntos usuarios la marcaron como favorita, etc., para el due√±o (si el viewer es el propietario, mostrar estas estad√≠sticas).
  - Debajo, listar comentarios/rese√±as si existen, mostrando texto, autor y rating.
- **Pantalla Crear/Editar Publicaci√≥n:**
  - Formulario (`Form` + `TextFormField`) con campos: tipo (DropdownButton o opciones predefinidas), raza (texto o dropdown si hay cat√°logo), edad (TextField num√©rico), cantidad, descripci√≥n (multil√≠nea), ubicaci√≥n (ej. Dropdown de estados o campo de texto autocompletable), y carga de imagen (bot√≥n para seleccionar foto de la galer√≠a/c√°mara).
  - Validar localmente campos obligatorios y formatos (no textos vac√≠os, n√∫meros > 0 en edad/cantidad). Utilizar validadores en los `TextFormField` para feedback inmediato.
  - Bot√≥n **Guardar**: al presionar, llamar `ListingProvider.createListing` o `updateListing` seg√∫n modo. Manejar estado de env√≠o (`isSubmitting=true` para mostrar spinner sobre el bot√≥n).
  - Si el backend retorna errores de validaci√≥n (422), capturar en el provider y mostrarlos en el formulario (por ejemplo, usando `validator` de cada campo con mensajes del provider, o un widget de texto rojo debajo del campo).
  - Tras una creaci√≥n/edici√≥n exitosa, navegar de regreso: si es nueva publicaci√≥n, puede volver al Marketplace o directamente al detalle de la publicaci√≥n creada; si es edici√≥n, volver al detalle actualizado.
- **Pantalla Mi Perfil:**
  - Mostrar la informaci√≥n del usuario actual (desde `AuthProvider.currentUser`): foto de perfil (CircleAvatar), nombre, ubicaci√≥n, email/tel√©fono (si se quiere mostrar en perfil privado), bio, rating promedio y n√∫mero de calificaciones, estado verificado (insignia verificada si `isVerified=true`).
  - Bot√≥n **Editar Perfil**: navega a una pantalla o di√°logo para editar los datos de perfil (nombre, contacto, ubicaci√≥n, bio, foto). Similar a formulario de publicaci√≥n pero para User: campos b√°sicos y opci√≥n de nueva foto de perfil.
  - Secci√≥n **Mis Publicaciones**: debajo de la info del perfil, listar las publicaciones creadas por el usuario (usar `ListingProvider.listings` filtradas por ownerId o mantener un m√©todo para obtener solo las del usuario). Mostrar cada publicaci√≥n con sus m√©tricas (vistas, interesados, estado activo/vendido si aplica). Permitir entrar a detalle o editar directamente.
  - Opcional: mostrar notificaci√≥n si el usuario no est√° verificado (‚ÄúTu cuenta no est√° verificada. Completa X proceso para verificar.‚Äù) para incentivar la verificaci√≥n.
- **Pantalla Perfil de Vendedor (otro usuario):**
  - Similar a una vista de perfil pero para un vendedor ajeno: mostrar nombre comercial, ubicaci√≥n, bio, rating y verificado. No mostrar datos sensibles (email, tel√©fono).
  - Listar tambi√©n las publicaciones activas de ese vendedor (para que el comprador pueda ver m√°s ofertas del mismo). 
  - Bot√≥n **Contactar** presente (redundante con el de detalle, pero √∫til si se llega al perfil por otro medio).
- **Pantalla de Conversaciones (MessagesScreen):**
  - **Estructura:** Usar `Scaffold` con `AppBar` (t√≠tulo "Mensajes") y `body` con `ListView.builder` de conversaciones
  - **Fuente de datos:** `Consumer<ChatProvider>` para reactividad, obtener `conversations` del provider
  - **Widget por conversaci√≥n:** `ConversationCard` customizado que muestra:
    - `CircleAvatar` con foto del otro participante (o inicial si no tiene foto)
    - Nombre del contacto en negrita (usar `TextStyle(fontWeight: FontWeight.bold)`)
    - Snippet del √∫ltimo mensaje (m√°x 50 caracteres con ellipsis)
    - Timestamp relativo usando `timeago` package ("hace 5 min", "ayer", etc.)
    - Badge circular rojo con n√∫mero de no le√≠dos si `conversation.unreadCount > 0`
    - Indicador verde peque√±o si el otro usuario est√° online (`isOnline`)
    - Icono de verificado (‚úì) si el contacto tiene `isVerified=true`
  - **Interacciones:**
    - Al entrar a la pantalla: `ChatProvider.loadConversations()` en `initState()`
    - Pull-to-refresh: `RefreshIndicator` que llama `loadConversations()` nuevamente
    - Tap en conversaci√≥n: navega a `ChatScreen` con `Navigator.push()` pasando `conversationId`
    - Swipe-to-delete: usar `Dismissible` para eliminar conversaci√≥n (con confirmaci√≥n)
  - **Estados especiales:**
    - Loading: `CircularProgressIndicator` centrado si `isLoading=true`
    - Empty: Widget centrado con icono de chat vac√≠o y mensaje "No tienes conversaciones a√∫n"
    - Error: `SnackBar` con mensaje de error si falla la carga
  - **Badge en BottomNavigationBar:** Mostrar badge rojo con `unreadCount` total en el √≠cono de mensajes
  
- **Pantalla de Chat 1:1 (ChatScreen):**
  - **AppBar personalizado:**
    - Leading: bot√≥n back
    - Title: Row con avatar peque√±o + nombre del contacto + indicador online/offline
    - Subtitle: Estado de conexi√≥n WebSocket ("Conectado", "Reconectando...", "Sin conexi√≥n")
    - Actions: IconButton de opciones (bloquear, eliminar conversaci√≥n)
  - **Body - Lista de mensajes:**
    - `ListView.builder` con `reverse: true` (mensajes m√°s recientes abajo)
    - Cada mensaje usa widget `MessageBubble`:
      - Mensajes enviados: alineados a la derecha, color `theme.colorScheme.primaryContainer`
      - Mensajes recibidos: alineados a la izquierda, color `theme.colorScheme.surfaceVariant`
      - Contenido del mensaje en `Text` con manejo de multiline
      - Timestamp peque√±o debajo (formato "12:34 PM")
      - Estados visuales:
        - "Enviando": Spinner peque√±o gris
        - "Enviado": Check gris (‚úì)
        - "Entregado": Doble check gris (‚úì‚úì)
        - "Le√≠do": Doble check azul (‚úì‚úì)
        - "Fallido": Icono de error rojo con bot√≥n "Reintentar"
    - Auto-scroll al √∫ltimo mensaje cuando se env√≠a o recibe mensaje nuevo
    - Separador de fecha entre mensajes de d√≠as diferentes
  - **Typing Indicator:**
    - Widget `TypingIndicator` que aparece sobre el input cuando el otro usuario est√° escribiendo
    - Animaci√≥n de 3 puntos rebotando
    - Texto: "Usuario est√° escribiendo..."
  - **Input de mensaje (parte inferior):**
    - `Row` con `TextField` expandido y `IconButton` de enviar
    - TextField con:
      - Placeholder: "Escribe un mensaje..."
      - `maxLines: null` para permitir multiline (hasta 5 l√≠neas)
      - `textCapitalization: TextCapitalization.sentences`
      - `onChanged`: Detectar escritura y enviar evento de typing v√≠a WebSocket cada 3 segundos
    - Bot√≥n enviar:
      - Deshabilitado si texto vac√≠o o `isSending=true`
      - Al presionar: `ChatProvider.sendMessage(convId, text)` y limpiar TextField
      - Mostrar spinner mientras `isSending=true`
  - **Indicador de estado de conexi√≥n:**
    - Banner peque√±o arriba si `connectionState != connected`
    - "üî¥ Sin conexi√≥n - Los mensajes se enviar√°n cuando reconectes"
    - "üü° Reconectando..."
    - Desaparece autom√°ticamente cuando reconecta
  - **WebSocket en tiempo real:**
    - Al entrar a la pantalla: `WebSocketService` ya debe estar conectado (desde `ChatProvider.init()`)
    - Escuchar evento `onMessage`: si el mensaje es de esta conversaci√≥n, agregarlo al ListView
    - Escuchar evento `onTyping`: mostrar/ocultar `TypingIndicator`
    - Escuchar evento `onConnectionChange`: actualizar indicador de conexi√≥n
  - **Marcar como le√≠do:**
    - Cuando usuario entra a ChatScreen, llamar `ChatProvider.markAsRead(convId)` en `initState()`
    - Esto actualiza backend y decrementa `unreadCount` local
  - **Navegaci√≥n desde ProductDetail:**
    - Bot√≥n "Contactar Vendedor" en `ProductDetailScreen`
    - Al presionar: `ChatProvider.openConversation(sellerId, productId: product.id)`
    - Navega a `ChatScreen` con la conversaci√≥n creada/abierta
    - El primer mensaje puede incluir contexto del producto: "Hola, me interesa [Nombre del producto]"
- **Pantallas de Autenticaci√≥n:**
  - **LoginScreen:** campos para email y contrase√±a, con validaci√≥n b√°sica (no vac√≠o, formato email). Bot√≥n "Iniciar Sesi√≥n" que al presionar llama `AuthProvider.login(email, pass)`. Mostrar indicador de carga durante autenticaci√≥n. Si error (credenciales inv√°lidas), mostrar mensaje ("Email o contrase√±a incorrecta").
  - **RegisterScreen:** campos para nombre, email, tel√©fono, contrase√±a y confirmaci√≥n. Validar formatos (email v√°lido, tel√©fono quiz√°s opcional pero formato num√©rico, contrase√±a m√≠nima 6 caracteres y coincide con confirmaci√≥n). Bot√≥n "Registrarse" llama `AuthProvider.register(datos)` y luego inicia sesi√≥n autom√°tica o indica √©xito.
  - Tras login o registro exitoso, navegar a la pantalla principal (MarketplaceScreen). Mantener la sesi√≥n guardando token en SecureStorage y cargando datos de usuario.
  - Considerar un SplashScreen inicial que verifique si ya hay un token v√°lido al abrir la app: 
    - Si s√≠, saltar login (ir directo a home tras cargar perfil mediante AuthService.getProfile).
    - Si no, mostrar pantallas de bienvenida/login.

## Manejo de Errores y Validaciones en la UI
- Dar feedback claro al usuario en caso de errores:
  - Si el backend devuelve error de validaci√≥n (422) con detalles, parsear los mensajes y mostrarlos junto a los campos correspondientes en formularios (usando `FormField.errorText` o widgets de texto de error).
  - Si devuelve error de autenticaci√≥n (401 no autorizado), redirigir al login (por ejemplo, si el token expir√≥, asegurar que las pr√≥ximas llamadas AuthService fallen y triggereen logout).
  - Errores generales (500 o desconocidos): mostrar un mensaje gen√©rico mediante un `SnackBar` o `AlertDialog` ("Ocurri√≥ un error, int√©ntalo m√°s tarde") para no dejar al usuario sin retroalimentaci√≥n.
- Validar en el frontend antes de enviar para mejorar UX: por ejemplo, campos obligatorios marcados con `*`, y usar validadores en `TextFormField` para evitar llamadas innecesarias al backend. Sin embargo, siempre manejar tambi√©n la respuesta de error del backend en caso de que pase una validaci√≥n del lado cliente.
- Manejar estados de carga con indicaciones visuales:
  - Mostrar **loaders** (ej. `CircularProgressIndicator`) mientras se cargan datos iniciales de una pantalla. Por ejemplo, MarketplaceScreen muestra un spinner central si `ListingProvider.isLoading` y la lista vac√≠a.
  - Deshabilitar botones mientras se procesa una acci√≥n: ej. bot√≥n "Guardar" del formulario de publicaci√≥n se desactiva durante el env√≠o para prevenir env√≠os duplicados, mostrando quiz√° un spinner peque√±o en el propio bot√≥n.
  - Para acciones r√°pidas (like/unlike favorito), retroalimentar con cambios inmediatos en el icono, pero confirmar el estado real seg√∫n la respuesta del backend (y revertir si fall√≥).
- Implementar estados vac√≠os y mensajes informativos:
  - Ej.: Si `ListingProvider.listings` est√° vac√≠o tras cargar, mostrar texto "No se encontraron publicaciones" (quiz√° debido a filtros activos o sin datos en la plataforma).
  - En la pantalla de chats, si no hay conversaciones: mostrar un mensaje "No tienes mensajes a√∫n. ¬°Empieza a contactar vendedores desde una publicaci√≥n!".
  - Estos mensajes mejoran la UX y gu√≠an al usuario sobre qu√© hacer.

## Responsabilidades Cruzadas y Sincronizaci√≥n con Backend
- El frontend depende del backend para la veracidad de datos. Siempre que la app realice una acci√≥n (crear, editar, eliminar), esperar la respuesta confirmada del servidor antes de actualizar la UI definitivamente:
  - Ej.: al eliminar una publicaci√≥n, no quitarla de la lista inmediatamente al hacer clic, sino tras confirmar √©xito (mientras tanto, se puede optim√≠sticamente ocultar con un placeholder de "eliminando..." o deshabilitarla).
  - Si el backend responde con error (403, 404, etc.), mostrar el error y restaurar cualquier cambio optimista en la interfaz.
- Mantener los modelos de datos del frontend sincronizados con la API:
  - Si cambia la estructura JSON en el backend (ej. se renombra un campo), actualizar los m√©todos `fromJson`/`toJson` y el uso correspondiente en la app. Este archivo de reglas debe actualizarse tambi√©n si hay cambios mayores de contrato.
  - **NUNCA usar URLs hardcodeadas** - Siempre usar `AppConfig.apiUrl` o `AppConfig.apiBaseUrl` para obtener la URL correcta seg√∫n el entorno
  - Las URLs se configuran en `.env` y se leen desde `AppConfig`:
    - `AppConfig.apiUrl` ‚Üí URL base de la API (detecta autom√°ticamente local/test/production)
    - `AppConfig.apiBaseUrl` ‚Üí URL completa con `/api` (ej: `https://corralx.com/api`)
    - `AppConfig.wsUrl` ‚Üí URL de WebSocket seg√∫n el entorno
- **Seguridad en frontend:** aunque el token previene acceso no autorizado, su manejo debe ser cuidadoso:
  - Guardar token de forma segura (usar `flutter_secure_storage` en vez de SharedPreferences para informaci√≥n sensible).
  - Nunca exponer el token ni informaci√≥n sensible en los logs de la app. 
  - Si el usuario cierra sesi√≥n, borrar token y datos personales. 
  - Implementar detecci√≥n de expiraci√≥n: si una llamada recibe 401 y el token estaba enviado, asumir expirado o inv√°lido, realizar `logout()` autom√°tico y redirigir a login.
- Optimizar la experiencia de chat con WebSockets:
  - Implementar conexi√≥n WebSocket persistente para chat en tiempo real usando `web_socket_channel`.
  - Manejar estados de conexi√≥n: conectado, desconectado, reconectando, con indicadores visuales en la UI.
  - Implementar reconexi√≥n autom√°tica con backoff exponencial en caso de p√©rdida de conexi√≥n.
  - Pausar la conexi√≥n WebSocket cuando la app est√° en segundo plano para optimizar recursos.
  - Implementar notificaciones push para mensajes recibidos cuando la app est√° en background.
- El flujo de pedidos y entrega debe respetar la regla ‚Äúpago fuera de la app‚Äù: mostrar mensajes claros en comprobante y pantallas relevantes, evitando suposiciones de procesamiento digital.
- El frontend debe reflejar las reglas del backend en la UI para claridad del usuario:
  - Ej.: Si solo usuarios verificados pueden publicar (si se aplicara), la app deber√≠a informar o bloquear esa acci√≥n para usuarios no verificados con un mensaje del estilo "Tu cuenta debe ser verificada para publicar anuncios.".
  - Si un campo es obligatorio seg√∫n backend, marcarlo como obligatorio en el formulario con un asterisco y evitar permitir enviar hasta que est√© lleno.
- Pruebas manuales de integraci√≥n: el equipo frontend y backend deben realizar pruebas conjuntas de los flujos principales (registro, login, crear publicaci√≥n, navegar, chatear) en un entorno de staging. Cualquier fallo de integraci√≥n (discordancia de nombres de campos, comportamiento inesperado) debe reflejarse en ajustes tanto de c√≥digo como de estas reglas para mantener la documentaci√≥n actualizada.

## Configuraci√≥n de Entornos y URLs (3 Niveles)

### Sistema de Detecci√≥n Autom√°tica de Entornos
- **Implementaci√≥n:** `AppConfig` en `lib/config/app_config.dart` detecta autom√°ticamente el entorno seg√∫n el tipo de compilaci√≥n
- **3 Entornos configurados:**
  1. **`local`** (Debug): Desarrollo local ‚Üí `http://192.168.27.12:8000`
  2. **`test`** (Release APK): Pruebas ‚Üí `https://test.corralx.com`
  3. **`production`** (AAB): Producci√≥n ‚Üí `https://corralx.com`

### L√≥gica de Detecci√≥n
- **Prioridad 1:** `--dart-define=BUILD_TYPE=...` (tiene m√°xima prioridad, usado para AAB production)
- **Prioridad 2:** `kDebugMode == true` ‚Üí `local` (Debug APK)
- **Prioridad 3:** `kReleaseMode == true` sin flag ‚Üí `test` (Release APK local)

### Variables de Entorno (`.env`)
- **API URLs:** `API_URL_LOCAL`, `API_URL_TEST`, `API_URL_PROD`
- **WebSocket URLs:** `WS_URL_LOCAL`, `WS_URL_TEST`, `WS_URL_PROD`
- **Dominios:** `APP_DOMAIN`, `APP_DOMAIN_LOCAL`, `CONTACT_EMAIL`
- **Todas las URLs se leen desde `.env`** - NO usar valores hardcodeados

### Comandos de Compilaci√≥n
```bash
# 1. Debug (local)
flutter run -d 192.168.27.5:5555
# ‚Üí buildType: 'local' ‚Üí API_URL_LOCAL

# 2. Release APK (test)
flutter run -d 192.168.27.5:5555 --release
# ‚Üí buildType: 'test' ‚Üí API_URL_TEST

# 3. AAB Production
flutter build appbundle --release --dart-define=BUILD_TYPE=production
# ‚Üí buildType: 'production' ‚Üí API_URL_PROD
```

### Uso en C√≥digo
- **Siempre usar `AppConfig.apiUrl`** en lugar de URLs hardcodeadas
- `AppConfig.apiUrl` retorna autom√°ticamente la URL correcta seg√∫n `buildType`
- `AppConfig.wsUrl` retorna la URL de WebSocket correspondiente
- `AppConfig.currentAppDomain` retorna el dominio correcto para deep links

### Verificaci√≥n
- ‚úÖ Las 3 compilaciones fueron probadas exitosamente
- ‚úÖ Cada entorno apunta correctamente a su URL correspondiente
- ‚úÖ No hay valores hardcodeados en el c√≥digo

## Configuraci√≥n de Google OAuth para Play Store (AAB)
- **Problema cr√≠tico:** Cuando se sube un AAB a Play Store, Google Play re-firma la aplicaci√≥n con su propia App Signing Key (ASK). El SHA-1/SHA-256 que se necesita registrar es el de la ASK de Google Play, NO el del keystore de carga.
- **Soluci√≥n implementada:** Sistema de detecci√≥n autom√°tica del tipo de compilaci√≥n en `build.gradle`:
  - **Debug APK** (`flutter run -d <device>`): Usa Client ID de Upload Key (`332023551639-bbhv3lmlbgeu9t7oap48k006m7uf0lkh.apps.googleusercontent.com`)
  - **Release APK Local** (`flutter run -d <device> --release`): Usa Client ID de Upload Key
  - **AAB Play Store** (`flutter build appbundle --release --dart-define=BUILD_TYPE=production`): Usa Client ID de Play Store ASK (`332023551639-840baceq4uf1n93d6rc65svha1o0434o.apps.googleusercontent.com`)
- **Implementaci√≥n en build.gradle:**
  - El `buildType.release` detecta autom√°ticamente si se est√° compilando un bundle (AAB) o un assemble (APK) usando `gradle.startParameter.taskNames.any { it.contains('bundle') }`
  - Se configuran `manifestPlaceholders` din√°micamente seg√∫n el tipo de compilaci√≥n
  - El `AndroidManifest.xml` usa `${googleOauthClientId}` como placeholder
- **Configuraci√≥n requerida en consolas:**
  - **Google Cloud Console:** Ambos SHA-1 deben estar registrados en el mismo OAuth Client ID (Upload Key SHA-1 y Play Store ASK SHA-1)
  - **Firebase Console:** Ambos SHA-1 y SHA-256 deben estar agregados en la configuraci√≥n de la app Android, y se debe descargar un nuevo `google-services.json` que incluya ambos OAuth Client IDs
  - **Google Play Console:** Obtener SHA-1/SHA-256 de la App Signing Key desde "Integridad de la app" (App Integrity)
- **Versioning:** El `versionCode` y `versionName` se leen autom√°ticamente desde `pubspec.yaml` usando `flutter.versionCode` y `flutter.versionName` en `build.gradle`. Siempre incrementar el `versionCode` en `pubspec.yaml` antes de compilar un nuevo AAB para Play Store.

## Inteligencia Artificial y Anal√≠tica IA Insights
- Se a√±ade un cuarto bot√≥n en el `AppBar` de `ProfileScreen` para abrir la secci√≥n `IA Insights`. Mantener consistencia visual y estados activos como los dem√°s botones.
- La secci√≥n `IA Insights` debe consumir m√©tricas centralizadas expuestas por el backend. Al dise√±ar providers y servicios:
  - `IAInsightsProvider` gestionar√° estados de carga, errores y resultados separados por rol (free, premium, admin).
  - Las respuestas del backend deben incluir m√©tricas crudas y res√∫menes generados por IA cuando est√©n disponibles.
- **Segmentaci√≥n por rol:**
  - `Free`: mostrar KPIs b√°sicos (vistas, favoritos, mensajes) y un √∫nico insight en lenguaje natural. Incluir llamado a la acci√≥n para actualizar a Premium.
  - `Premium`: habilitar filtros por fecha, comparativas contra el promedio del marketplace, proyecciones y recomendaciones accionables.
  - `Admin`: vista global con m√©tricas agregadas por regi√≥n/categor√≠a, detecci√≥n de anomal√≠as y alertas operativas.
- Al integrar GPT/Gemini/DeepSeek:
  - Encapsular la l√≥gica de prompts en un servicio (`IAInsightsService`) para facilitar el cambio de proveedor.
  - Cachear resultados recientes para evitar llamadas repetidas y controlar costos.
  - Garantizar que los prompts nunca expongan datos sensibles (IDs internos, tokens).
- UI recomendada para `IA Insights`:
  - Tarjeta de resumen r√°pido (highlights de la semana).
  - Lista de recomendaciones priorizadas.
  - Historial de acciones sugeridas (mostrar si fueron marcadas como completadas).
  - Filtros de rango de fechas (d√≠a, semana, mes, hist√≥rico) y selector de hacienda/producto para premium/admin.
- Definir un inventario de m√©tricas recolectadas (vistas por publicaci√≥n, clics, contactos abiertos, rating, estado de anuncios, etc.) antes de implementar la pantalla. Documentar cada m√©trica en el backend y sincronizar naming con el frontend.
- Actualizar esta gu√≠a y el README cuando se agreguen nuevas capacidades (ej. integraciones externas, nuevas recomendaciones).

## Especificaci√≥n de UI del Demo (HTML)
- Navegaci√≥n inferior: Mercado, Favoritos, Publicar, Mensajes (con badge de no le√≠dos), Perfil.
- Vistas: `marketplace`, `detail`, `create`, `profile`, `editProfile`, `favorites`, `dashboard`, `myListings`, `messages`, `chat`, `marketPulse`, `admin*`, `termsAndConditions`.
- Marketplace: b√∫squeda, filtro por tipo (`all|lechero|engorde|padrote`), filtro por ubicaci√≥n, secci√≥n Destacadas y Recientes.
- Detalle: miniaturas con selecci√≥n, favorito, reporte, registro del animal (con/sin certificado), vendedor con insignia de verificado, editar/eliminar si es due√±o, comentarios con estrellas (1‚Äì5) y rec√°lculo de rating promedio del vendedor.
- Crear/Editar: hasta 5 fotos (primera = portada), validaci√≥n de certificado si `con-registro`, campos tipo/raza/edad/cantidad/ubicaci√≥n/descr., toggle Destacado.
- Perfil: avatar, nombre comercial, full name, bio, rating, verificado, fecha de alta, contacto y ubicaci√≥n; listado de publicaciones del usuario; secci√≥n "Legal" con acceso a T√©rminos y Condiciones y Pol√≠tica de Privacidad.
- Favoritos: rejilla de publicaciones marcadas.
- Dashboard/Mis publicaciones: m√©tricas (publicaciones, vistas, favoritos) y lista editable.
- Mensajes/Chat: conversaciones con snippet del √∫ltimo mensaje; chat 1:1 con input; al entrar a `messages` se limpian no le√≠dos.
- T√©rminos y Condiciones: pantalla reutilizable (`TermsAndConditionsScreen`) que muestra T√©rminos de Servicio o Pol√≠tica de Privacidad seg√∫n el par√°metro `type`. Accesible desde `SignInScreen` (links clickeables) y desde `ProfileScreen` (secci√≥n Legal).
- MarketPulse: genera resumen (mock) con tendencias por tipo/ubicaci√≥n.
- Admin (mock): dashboard, publicaciones, usuarios, actividad, soporte a usuario y reportes.

### Comportamientos clave
- Bot√≥n favorito con animaci√≥n "pop" y estado.
- Modal de certificado con bloqueo de scroll y cierre por overlay o bot√≥n.
- L√≠mite 5 im√°genes y ocultar caja de subida al alcanzar l√≠mite.
- Chips de filtro con estado activo y select de ubicaci√≥n.
- Badge de no le√≠dos en nav y limpieza al abrir `messages`.
- Links de T√©rminos y Condiciones en pantalla de login son clickeables y navegan a `TermsAndConditionsScreen`.

## Sistema de Colores y Temas

### Paleta de Colores - Modo Claro
```css
/* Variables CSS para Flutter (usar en corral_x_theme.dart) */
const Color primaryColor = Color(0xFF386A20);                    // Verde principal
const Color onPrimaryColor = Color(0xFFFFFFFF);                 // Blanco sobre verde
const Color primaryContainerColor = Color(0xFFB7F399);          // Verde claro contenedor
const Color onPrimaryContainerColor = Color(0xFF082100);       // Verde oscuro sobre contenedor
const Color secondaryColor = Color(0xFF55624C);                 // Verde secundario
const Color onSecondaryColor = Color(0xFFFFFFFF);               // Blanco sobre secundario
const Color secondaryContainerColor = Color(0xFFD9E7CA);        // Verde claro secundario
const Color onSecondaryContainerColor = Color(0xFF131F0D);     // Verde oscuro sobre secundario
const Color errorColor = Color(0xFFBA1A1A);                     // Rojo de error
const Color onErrorColor = Color(0xFFFFFFFF);                   // Blanco sobre error
const Color backgroundColor = Color(0xFFFCFDF7);                // Fondo principal (crema)
const Color onBackgroundColor = Color(0xFF1A1C18);              // Texto sobre fondo
const Color surfaceColor = Color(0xFFFCFDF7);                   // Superficie principal
const Color onSurfaceColor = Color(0xFF1A1C18);                 // Texto sobre superficie
const Color surfaceVariantColor = Color(0xFFE0E4D7);           // Variante de superficie
const Color onSurfaceVariantColor = Color(0xFF43483E);          // Texto sobre variante
const Color outlineColor = Color(0xFF74796D);                   // Color de borde/outline
const Color surfaceContainerHighColor = Color(0xFFE9E9E2);     // Contenedor alto
const Color surfaceContainerLowColor = Color(0xFFF4F4ED);      // Contenedor bajo
```

### Paleta de Colores - Modo Oscuro
```css
/* Variables CSS para Flutter (usar en corral_x_theme.dart) */
const Color primaryColorDark = Color(0xFF9CDA7F);              // Verde claro principal
const Color onPrimaryColorDark = Color(0xFF082100);            // Verde oscuro sobre principal
const Color primaryContainerColorDark = Color(0xFF1F3314);     // Verde oscuro contenedor
const Color onPrimaryContainerColorDark = Color(0xFFB7F399);   // Verde claro sobre contenedor
const Color secondaryColorDark = Color(0xFFBCCAB0);            // Verde claro secundario
const Color onSecondaryColorDark = Color(0xFF263420);          // Verde oscuro sobre secundario
const Color secondaryContainerColorDark = Color(0xFF3A4A2F);   // Verde medio contenedor
const Color onSecondaryContainerColorDark = Color(0xFFD9E7CA); // Verde claro sobre contenedor
const Color errorColorDark = Color(0xFFFFB4AB);                // Rojo claro de error
const Color onErrorColorDark = Color(0xFF690005);              // Rojo oscuro sobre error
const Color backgroundColorDark = Color(0xFF1A1C18);           // Fondo principal (negro verdoso)
const Color onBackgroundColorDark = Color(0xFFE0E4D7);         // Texto claro sobre fondo
const Color surfaceColorDark = Color(0xFF2B2D28);              // Superficie principal
const Color onSurfaceColorDark = Color(0xFFE0E4D7);            // Texto claro sobre superficie
const Color surfaceVariantColorDark = Color(0xFF43483E);       // Variante de superficie
const Color onSurfaceVariantColorDark = Color(0xFFC4C8BB);     // Texto sobre variante
const Color outlineColorDark = Color(0xFF8E9388);              // Color de borde/outline
const Color surfaceContainerHighColorDark = Color(0xFF2F312C); // Contenedor alto
const Color surfaceContainerLowColorDark = Color(0xFF1F211C);  // Contenedor bajo
```

### Implementaci√≥n en Flutter
```dart
// En corral_x_theme.dart
class CorralXTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF386A20),
        brightness: Brightness.light,
        primary: const Color(0xFF386A20),
        onPrimary: const Color(0xFFFFFFFF),
        primaryContainer: const Color(0xFFB7F399),
        onPrimaryContainer: const Color(0xFF082100),
        secondary: const Color(0xFF55624C),
        onSecondary: const Color(0xFFFFFFFF),
        secondaryContainer: const Color(0xFFD9E7CA),
        onSecondaryContainer: const Color(0xFF131F0D),
        error: const Color(0xFFBA1A1A),
        onError: const Color(0xFFFFFFFF),
        background: const Color(0xFFFCFDF7),
        onBackground: const Color(0xFF1A1C18),
        surface: const Color(0xFFFCFDF7),
        onSurface: const Color(0xFF1A1C18),
        surfaceVariant: const Color(0xFFE0E4D7),
        onSurfaceVariant: const Color(0xFF43483E),
        outline: const Color(0xFF74796D),
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF9CDA7F),
        brightness: Brightness.dark,
        primary: const Color(0xFF9CDA7F),
        onPrimary: const Color(0xFF082100),
        primaryContainer: const Color(0xFF1F3314),
        onPrimaryContainer: const Color(0xFFB7F399),
        secondary: const Color(0xFFBCCAB0),
        onSecondary: const Color(0xFF263420),
        secondaryContainer: const Color(0xFF3A4A2F),
        onSecondaryContainer: const Color(0xFFD9E7CA),
        error: const Color(0xFFFFB4AB),
        onError: const Color(0xFF690005),
        background: const Color(0xFF1A1C18),
        onBackground: const Color(0xFFE0E4D7),
        surface: const Color(0xFF2B2D28),
        onSurface: const Color(0xFFE0E4D7),
        surfaceVariant: const Color(0xFF43483E),
        onSurfaceVariant: const Color(0xFFC4C8BB),
        outline: const Color(0xFF8E9388),
      ),
    );
  }
}
```

### Persistencia de Tema
```dart
// Usar SharedPreferences para guardar preferencia de tema
class ThemeProvider extends ChangeNotifier {
  bool _isDarkMode = false;
  bool get isDarkMode => _isDarkMode;

  Future<void> toggleTheme() async {
    _isDarkMode = !_isDarkMode;
    await SharedPreferences.getInstance().then((prefs) {
      prefs.setBool('isDarkMode', _isDarkMode);
    });
    notifyListeners();
  }

  Future<void> loadTheme() async {
    final prefs = await SharedPreferences.getInstance();
    _isDarkMode = prefs.getBool('isDarkMode') ?? false;
    notifyListeners();
  }
}
```

## üîÄ FLUJO DE TRABAJO CON GIT (OBLIGATORIO)

### Estrategia de Ramas

**CR√çTICO:** Este proyecto utiliza un flujo de trabajo estricto con dos ramas:

1. **`dev`** - Rama de pruebas/testing
   - **Backend:** Se despliega autom√°ticamente a `test.corralx.com`
   - **Frontend:** Debe probar contra la API de `test.corralx.com`
   - **SIEMPRE hacer push aqu√≠ primero**

2. **`main`** - Rama de producci√≥n
   - **Backend:** Se despliega autom√°ticamente a `corralx.com`
   - **Frontend:** Debe probar contra la API de `corralx.com`
   - **Solo merge cuando est√©s 100% seguro**

### Permisos y Roles

#### üëë ADMIN (Solo el administrador principal - el usuario)
- ‚úÖ Puede hacer **push directamente a `dev`**
- ‚úÖ Puede hacer **push directamente a `main`** (solo √©l)
- ‚úÖ Puede hacer **merge de `dev` ‚Üí `main`** (solo √©l, cuando apruebe los cambios)

#### üë®‚Äçüíª PROGRAMADOR (No admin)
- ‚úÖ Puede hacer **push a `dev`** solamente
- ‚ùå **NO puede hacer push directo a `main`**
- ‚ùå **NO puede hacer merge de `dev` ‚Üí `main`** (solo el admin puede)

### Proceso OBLIGATORIO

#### Para ADMIN:

**OPCI√ìN 1: Flujo Normal (Recomendado)**
```bash
# 1. Trabajar en dev
git checkout dev
git pull origin dev

# 2. Hacer cambios y commits
git add .
git commit -m "feat: descripci√≥n"

# 3. Push a dev (pruebas)
git push origin dev
# ‚úÖ Backend se despliega autom√°ticamente a test.corralx.com
# ‚úÖ Frontend debe probar contra la API de test.corralx.com

# 4. Verificar en test.corralx.com
# - Probar todos los cambios
# - Verificar que no hay errores
# - Ejecutar tests: flutter test

# 5. Si todo est√° bien, merge a main
git checkout main
git pull origin main
git merge dev
git push origin main
# ‚úÖ Backend se despliega autom√°ticamente a corralx.com
# ‚úÖ Frontend debe probar contra la API de corralx.com
```

**OPCI√ìN 2: Push Directo a Main (Solo Admin)**
```bash
# Si el admin est√° 100% seguro y quiere saltar pruebas
git checkout main
git pull origin main
git add .
git commit -m "feat: cambio directo a producci√≥n"
git push origin main
# ‚úÖ Backend se despliega autom√°ticamente a corralx.com
# ‚úÖ Frontend debe probar contra la API de corralx.com
```

#### Para PROGRAMADOR:

**Flujo √önico (Solo dev)**
```bash
# 1. Trabajar en dev
git checkout dev
git pull origin dev

# 2. Hacer cambios y commits
git add .
git commit -m "feat: descripci√≥n"

# 3. Push a dev (pruebas)
git push origin dev
# ‚úÖ Backend se despliega autom√°ticamente a test.corralx.com
# ‚úÖ Frontend debe probar contra la API de test.corralx.com

# 4. Esperar aprobaci√≥n del admin
# El admin revisar√° en test.corralx.com y har√° el merge a main
```

### Reglas CR√çTICAS

‚ö†Ô∏è **Para PROGRAMADORES:**
- ‚ùå **NUNCA intentar push a `main`** (ser√° rechazado por GitHub)
- ‚ùå **NUNCA intentar merge a `main`** (solo el admin puede)
- ‚úÖ **Siempre trabajar en `dev`** y esperar aprobaci√≥n del admin

‚úÖ **Flujo correcto para PROGRAMADOR:**
1. Cambios ‚Üí `dev` ‚Üí Push ‚Üí Probar en `test.corralx.com`
2. Notificar al admin para revisi√≥n
3. Admin verifica y hace merge a `main` si aprueba

‚úÖ **Flujo correcto para ADMIN:**
1. Cambios ‚Üí `dev` ‚Üí Push ‚Üí Probar en `test.corralx.com`
2. Si todo est√° bien ‚Üí Merge `dev` ‚Üí `main` ‚Üí Push ‚Üí Producci√≥n
3. O push directo a `main` si est√° 100% seguro

### Control de Acceso Resumido

| Acci√≥n | Admin | Programador |
|--------|-------|-------------|
| Push a `dev` | ‚úÖ S√≠ | ‚úÖ S√≠ |
| Push a `main` | ‚úÖ S√≠ | ‚ùå No |
| Merge `dev` ‚Üí `main` | ‚úÖ S√≠ | ‚ùå No |

**El asistente debe:**
- **NUNCA hacer push autom√°ticamente** - Solo cuando el usuario lo ordene expl√≠citamente
- **NUNCA hacer merge autom√°ticamente** - Solo cuando el usuario lo ordene expl√≠citamente
- Siempre hacer push a `dev` primero cuando el usuario (admin) lo solicite expl√≠citamente
- Si el usuario es admin y est√° seguro, puede sugerir push directo a `main` o merge desde `dev`
- NUNCA sugerir a programadores push directo a `main` o merge a `main`
- Recordar al usuario (admin) verificar en `test.corralx.com` antes de merge a `main` (a menos que est√© 100% seguro)
- Solo hacer merge a `main` cuando el usuario expl√≠citamente lo solicite y confirme que est√° seguro
- **El usuario prueba primero** y da la orden cuando est√° seguro

### Sincronizaci√≥n con Backend

**IMPORTANTE:** El frontend debe estar sincronizado con el backend:
- Si el backend tiene cambios en `dev`, el frontend debe probar contra `test.corralx.com`
- Si el backend tiene cambios en `main`, el frontend debe probar contra `corralx.com`
- Antes de hacer merge a `main` en frontend, verificar que el backend tambi√©n est√© actualizado en `main`
- Los cambios de API del backend deben reflejarse primero en `dev` antes de actualizar el frontend
