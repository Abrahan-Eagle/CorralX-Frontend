
## Frontend (Flutter) `.cursorrules`

```md
---
description: "Gu√≠a de desarrollo Frontend (Flutter) para el MVP de Corral X"
alwaysApply: true
---

## Arquitectura Modular y Convenciones (Flutter)
- Organizar el c√≥digo en la carpeta `lib/` usando una arquitectura modular por features:
  - **`lib/config/`** ‚Äì Configuraci√≥n central (app_config.dart, auth_utils.dart, corral_x_theme.dart, user_provider.dart).
  - **`lib/shared/`** ‚Äì Servicios y widgets compartidos entre m√≥dulos.
  - **`lib/auth/`** ‚Äì M√≥dulo de autenticaci√≥n (screens/, services/, models/, widgets/).
  - **`lib/onboarding/`** ‚Äì M√≥dulo de onboarding (screens/, services/, models/, widgets/).
  - **`lib/products/`** ‚Äì M√≥dulo de productos/marketplace (screens/, services/, models/, widgets/).
  - **`lib/chat/`** ‚Äì M√≥dulo de chat (screens/, services/, models/, widgets/).
  - **`lib/favorites/`** ‚Äì M√≥dulo de favoritos (screens/, services/, models/, widgets/).
  - **`lib/profiles/`** ‚Äì M√≥dulo de perfiles (screens/, services/, models/, widgets/).
  - Cada m√≥dulo contiene: `models/`, `screens/`, `services/`, `widgets/` espec√≠ficos de esa funcionalidad.
- Seguir convenciones de nombrado de Dart/Flutter:
  - Nombres de archivos y directorios en min√∫scula y con guiones bajos (snake_case), sin espacios ni may√∫sculas:contentReference[oaicite:0]{index=0}.
  - Nombres de clases en PascalCase (capitalizando cada palabra, e.j. class `ListingProvider`).
  - Nombres de variables y m√©todos en lowerCamelCase.
  - Evitar nombres muy largos; preferir claridad y brevedad (ej. `ListingsScreen` mejor que `AllListingsListScreen`).
- Mantener una estructura limpia: una pantalla por archivo; widgets auxiliares en archivos separados si son lo suficientemente complejos. Se puede agrupar sub-componentes dentro de carpetas por pantalla (ej. `screens/listing_detail/` con `listing_detail_screen.dart` y widgets relacionados).
- Incluir comentarios y documentaci√≥n en el c√≥digo para facilitar la lectura por el equipo (usar `///` para documentar clases y m√©todos p√∫blicos).
- Usar el patr√≥n **Provider** para gesti√≥n de estado por simplicidad en el MVP (evitar patrones m√°s complejos como BLoC o Riverpod a menos que el equipo los prefiera).

## Servicios y Comunicaci√≥n con la API
- Centralizar las llamadas HTTP en clases de servicio bajo `lib/services/`:
  - Crear un `ApiService` base que use paquetes como `http` (o `dio` si se prefiere) para manejar peticiones. Este servicio puede gestionar el token de autenticaci√≥n globalmente (p.ej., adjuntar header `Authorization: Bearer <token>` a cada request tras login).
  - Servicios espec√≠ficos por recurso: ej. un `ListingService` con m√©todos para la l√≥gica de publicaciones: `fetchListings({filters})`, `getListingDetail(id)`, `createListing(data)`, `updateListing(id, data)`, `deleteListing(id)`. Cada m√©todo realiza la petici√≥n REST correspondiente y retorna datos procesados (decodificados a Map o convertidos a modelo).
  - **AuthService:** m√©todos `login(email, pass)`, `register(datos)`, `logout()` que llaman a las rutas `/api/login`, `/api/register` y gestionan el almacenamiento seguro del token (usando `flutter_secure_storage` para el JWT, por ejemplo).
  - **ChatService:** m√©todos para obtener conversaciones (`getConversations()` -> GET `/api/chat/conversations`), obtener mensajes de un chat (`getMessages(convId)` -> GET `/api/chat/conversations/{id}/messages`) y enviar mensaje (`sendMessage(convId, text)` -> POST `/api/chat/conversations/{id}/messages`), marcar como le√≠do (`markAsRead(convId)` -> POST `/api/chat/conversations/{id}/read`), crear conversaci√≥n (`createConversation(participantId)` -> POST `/api/chat/conversations`), eliminar conversaci√≥n (`deleteConversation(convId)` -> DELETE `/api/chat/conversations/{id}`).
  - **WebSocketService:** manejo de conexi√≥n WebSocket para chat en tiempo real, incluyendo:
    - `connect()` - Establecer conexi√≥n persistente con el servidor WebSocket
    - `disconnect()` - Cerrar conexi√≥n cuando app va a background o cierra
    - `onMessage(callback)` - Escuchar mensajes entrantes en tiempo real
    - `sendMessage(message)` - Enviar mensaje a trav√©s de WebSocket
    - `onTyping(callback)` - Detectar cuando otro usuario est√° escribiendo
    - `reconnect()` - Reconexi√≥n autom√°tica con backoff exponencial (1s, 2s, 4s, 8s, max 30s)
    - `heartbeat()` - Keep-alive cada 30 segundos para mantener conexi√≥n
    - Manejo de estados: `connecting`, `connected`, `disconnected`, `reconnecting`, `error`
    - Cola de mensajes pendientes cuando hay p√©rdida temporal de conexi√≥n
    - Indicadores visuales de estado de conexi√≥n en la UI
  - **NotificationService:** integraci√≥n con Firebase Cloud Messaging (FCM) para notificaciones push:
    - `initialize()` - Configurar FCM al iniciar la app
    - `requestPermission()` - Solicitar permisos de notificaciones al usuario
    - `getToken()` - Obtener device token para env√≠o de notificaciones
    - `onMessageReceived(callback)` - Manejar notificaciones recibidas (foreground y background)
    - `showLocalNotification(title, body)` - Mostrar notificaci√≥n local
    - `navigateToChat(conversationId)` - Navegar a chat espec√≠fico al tocar notificaci√≥n
    - `updateBadgeCount(count)` - Actualizar badge de mensajes no le√≠dos
    - Notificaciones silenciosas cuando app est√° abierta, sonido/vibraci√≥n cuando est√° cerrada
    - Deep linking para abrir conversaci√≥n espec√≠fica desde notificaci√≥n
  - Manejar errores HTTP en estos servicios: si la respuesta tiene c√≥digo de error, interpretar y lanzar excepciones o retornar valores de error para que la UI pueda reaccionar. Ej.: 401 -> lanzar error de autenticaci√≥n (frontend redirige a login), 422 -> devolver lista de errores de validaci√≥n para mostrarlos en el formulario.
- Parsear las respuestas JSON en modelos Dart o mapas:
  - Si se definieron clases de modelo (con factory `fromJson`), usarlas para convertir las respuestas. Ej: `Listing.fromJson(json)` por cada elemento en la lista de listings.
  - Enviar datos al backend en formato JSON con `http.post/put` y encabezado `Content-Type: application/json`. Usar `jsonEncode` en los cuerpos, asegurando que los nombres de campos coinciden con los esperados por el backend.
- Implementar un mecanismo global de autenticaci√≥n:
  - Guardar el token del usuario (y posiblemente el objeto User) en un provider global (`AuthProvider`) al hacer login.
  - Adjuntar el token en **ApiService** en cada llamada (p.ej., configurar `http.Client` con un interceptor o a√±adir header en cada m√©todo de servicio).
  - El AuthProvider maneja verificar si hay token guardado al iniciar la app (auto-login) y la l√≥gica de cerrar sesi√≥n (borrar token de storage, limpiar estados).
- Manejar subida de archivos/im√°genes si aplica:
  - Para adjuntar foto en una publicaci√≥n o actualizar avatar, usar `ImagePicker` (para obtener la imagen local) y luego `http.MultipartRequest` o m√©todos de `dio` para enviar la imagen al backend (ya sea a un endpoint dedicado o incluido en el payload de creaci√≥n). El servicio correspondiente debe manejar la construcci√≥n de la petici√≥n multipart.
  - Asegurarse que el backend devuelva la URL o path de la imagen guardada, y actualizar el modelo (Listing o User) con ese dato para futuras solicitudes.
- Evitar l√≥gica de negocio compleja en las pantallas: delegar a los servicios y providers. Las pantallas solo invocan m√©todos de provider o service, esperan los resultados (futures) y muestran feedback (spinners, mensajes de error).

## Gesti√≥n de Estado (Provider) y Flujos de Datos
- Utilizar el paquete **provider** para manejo sencillo del estado:
  - En `main.dart`, envolver la app con `MultiProvider` registrando los ChangeNotifiers necesarios: `AuthProvider`, `ListingProvider`, `ChatProvider`, etc.
  - **AuthProvider:** mantiene info del usuario actual (usuario logueado) y su token. Expone propiedades como `isAuthenticated` y `currentUser`. Maneja `login()`/`register()`/`logout()` llamando a AuthService y notificando listeners en consecuencia.
  - **ListingProvider:** maneja la lista de publicaciones y las operaciones CRUD relacionadas.
    - Tiene una lista `listings` (inicialmente vac√≠a) y quiz√°s `Listing? selectedListing` para detalle. 
    - M√©todos: `fetchListings([filters])` llama a ListingService.fetchListings; al obtener datos, rellena `listings` y hace `notifyListeners()`. Opcionalmente recibe filtros de b√∫squeda y los pasa a la API.
    - `getListingDetail(id)` podr√≠a obtener detalle de una publicaci√≥n (o aprovechar los datos ya cargados en `listings`). 
    - `createListing(datos)` llama ListingService.createListing; si √©xito, a√±ade la nueva publicaci√≥n a `listings` y notifica. 
    - `updateListing(id, datos)` actualiza tanto v√≠a API como localmente en la lista (reemplazando el objeto modificado).
    - `deleteListing(id)` env√≠a DELETE a API y si √©xito, remueve la publicaci√≥n de `listings`.
    - Tambi√©n maneja filtros locales de ser necesario (aunque es preferible delegar filtrado al backend enviando query params).
  - **ChatProvider:** maneja las conversaciones y mensajes del chat con integraci√≥n completa de WebSocket y notificaciones:
    - **Estado:**
      - `List<Conversation> conversations` - Lista de todas las conversaciones del usuario
      - `Map<String, List<Message>> messagesByConv` - Mensajes organizados por conversaci√≥n
      - `int unreadCount` - Contador total de mensajes no le√≠dos (para badge)
      - `bool isLoading` - Indicador de carga inicial
      - `String? errorMessage` - Mensaje de error si falla alguna operaci√≥n
      - `WebSocketConnectionState connectionState` - Estado de conexi√≥n WebSocket (connecting/connected/disconnected/reconnecting)
      - `Map<String, bool> typingUsers` - Usuarios que est√°n escribiendo en cada conversaci√≥n
    - **M√©todos principales:**
      - `loadConversations()` - Obtiene lista de conversaciones v√≠a HTTP (ChatService.getConversations), ordena por fecha del √∫ltimo mensaje, actualiza `unreadCount` sumando no le√≠dos de todas las conversaciones
      - `openConversation(userId, {productId})` - Crea o abre conversaci√≥n existente: primero verifica si existe conversaci√≥n con ese usuario (busca en `conversations`), si no existe llama a ChatService.createConversation, luego carga mensajes con `loadMessages(convId)`, marca la conversaci√≥n como activa
      - `loadMessages(convId)` - Carga historial de mensajes v√≠a HTTP (ChatService.getMessages), guarda en `messagesByConv[convId]`, auto-marca como le√≠do si usuario entra a la pantalla de chat
      - `sendMessage(convId, text)` - Env√≠a mensaje con feedback optimista:
        1. Agrega mensaje localmente con estado "sending" (feedback optimista)
        2. Env√≠a a trav√©s de WebSocketService (si conectado) o ChatService (fallback HTTP)
        3. Al recibir confirmaci√≥n, actualiza estado a "sent" y asigna ID real del servidor
        4. Si falla, marca mensaje con estado "failed" y bot√≥n de reintento
        5. Actualiza `lastMessage` en la conversaci√≥n correspondiente
      - `markAsRead(convId)` - Marca mensajes como le√≠dos v√≠a HTTP (ChatService.markAsRead), actualiza contador local `unreadCount`, actualiza estado de mensajes en `messagesByConv[convId]` a "read"
      - `deleteConversation(convId)` - Elimina conversaci√≥n con confirmaci√≥n del usuario, llama ChatService.deleteConversation, remueve de `conversations` localmente
    - **Integraci√≥n WebSocket:**
      - En `init()` del provider, conecta WebSocketService y registra callbacks
      - `WebSocketService.onMessage((message) {...})` - Al recibir mensaje nuevo: agrega a `messagesByConv`, actualiza `lastMessage` de conversaci√≥n, incrementa `unreadCount` si no est√° en esa conversaci√≥n, dispara notificaci√≥n local si app en foreground
      - `WebSocketService.onTyping((convId, userId, isTyping) {...})` - Actualiza `typingUsers[convId]` para mostrar "Usuario est√° escribiendo..."
      - `WebSocketService.onConnectionChange((state) {...})` - Actualiza `connectionState` para mostrar indicador visual en UI
      - Si WebSocket se desconecta, mantiene cola de mensajes pendientes y los env√≠a cuando reconecte
    - **Integraci√≥n NotificationService:**
      - En `init()`, configura callback de NotificationService para manejar tap en notificaci√≥n
      - `NotificationService.onNotificationTap((convId) {...})` - Navega a ChatScreen con esa conversaci√≥n
      - Cuando llega mensaje nuevo y usuario NO est√° en esa conversaci√≥n, trigger notificaci√≥n push
  - Los providers deben notificar a la UI para refrescar: usar `notifyListeners()` tras cambios. En la UI, usar `Consumer<...>` o `context.watch()` para reconstruir widgets reactivos cuando cambie el estado.
- Manejar estados de carga y error en los providers:
  - Por ejemplo, `ListingProvider` puede tener `bool isLoading` mientras carga publicaciones, y `String? errorMessage` si falla la carga. La UI (MarketplaceScreen) debe revisar estos para mostrar un `CircularProgressIndicator` cuando `isLoading=true` o un mensaje de error si `errorMessage != null`.
  - Similar para operaciones de env√≠o: se puede tener `isSubmitting` en formularios (evita doble submit) y `validationErrors` para mostrar errores espec√≠ficos de campos.
  - `ChatProvider` podr√≠a tener indicadores `isSending` para deshabilitar el campo de texto mientras se env√≠a un mensaje, `isConnected` para mostrar el estado de la conexi√≥n WebSocket, y manejar una cola de mensajes pendientes si se quiere extender.

## Dise√±o de Pantallas y Navegaci√≥n
- Implementar una navegaci√≥n acorde a los flujos principales (se puede usar `Navigator.push`/`pop` o rutas nombradas con `onGenerateRoute`). Una barra de navegaci√≥n inferior puede facilitar el acceso a secciones: Marketplace, Chats, Perfil, etc.
- **Pantalla Marketplace (Listado Principal):**
  - Muestra la lista de publicaciones en venta utilizando `ListingProvider.listings`. Usar un `ListView.builder` con un widget personalizado (`ListingCard`) para cada item, mostrando foto principal, tipo/raza, ubicaci√≥n y posiblemente precio o edad.
  - En la parte superior, incluir barra de b√∫squeda y filtros (por raza, tipo, ubicaci√≥n). Al aplicar filtros, llamar `fetchListings` con par√°metros o filtrar la lista existente y notificar.
  - Implementar pull-to-refresh (usando `RefreshIndicator`) que dispare `fetchListings()` nuevamente desde el backend.
  - Al tocar una publicaci√≥n, navegar a la pantalla de detalle de publicaci√≥n (pasando el ID o el objeto Listing).
- **Pantalla Detalle de Publicaci√≥n:**
  - Muestra la informaci√≥n completa de la publicaci√≥n seleccionada: varias im√°genes (Carousel o PageView), descripci√≥n extensa, detalles (edad, cantidad, ubicaci√≥n espec√≠fica, fecha publicaci√≥n), y datos del vendedor (nombre comercial, ubicaci√≥n general, rating, verificado con insignia).
  - Botones contextuales:
    - **Contactar / Mensaje:** visible para usuarios que no son due√±os. Al pulsar, iniciar o abrir chat con el vendedor: llamar a `ChatProvider.openConversation(sellerId)` (posiblemente pasando tambi√©n listingId para contexto inicial) y navegar a ChatScreen.
    - **Editar / Eliminar:** visibles solo si el usuario actual es el propietario de la publicaci√≥n. *Editar* navega a la pantalla de formulario de publicaci√≥n con los datos precargados. *Eliminar* muestra confirmaci√≥n y si se acepta, llama `ListingProvider.deleteListing` y al √©xito hace `Navigator.pop()` (y quiz√° refresca la lista).
  - Mostrar m√©tricas: n√∫mero de vistas de la publicaci√≥n, cu√°ntos usuarios la marcaron como favorita, etc., para el due√±o (si el viewer es el propietario, mostrar estas estad√≠sticas).
  - Debajo, listar comentarios/rese√±as si existen, mostrando texto, autor y rating.
- **Pantalla Crear/Editar Publicaci√≥n:**
  - Formulario (`Form` + `TextFormField`) con campos: tipo (DropdownButton o opciones predefinidas), raza (texto o dropdown si hay cat√°logo), edad (TextField num√©rico), cantidad, descripci√≥n (multil√≠nea), ubicaci√≥n (ej. Dropdown de estados o campo de texto autocompletable), y carga de imagen (bot√≥n para seleccionar foto de la galer√≠a/c√°mara).
  - Validar localmente campos obligatorios y formatos (no textos vac√≠os, n√∫meros > 0 en edad/cantidad). Utilizar validadores en los `TextFormField` para feedback inmediato.
  - Bot√≥n **Guardar**: al presionar, llamar `ListingProvider.createListing` o `updateListing` seg√∫n modo. Manejar estado de env√≠o (`isSubmitting=true` para mostrar spinner sobre el bot√≥n).
  - Si el backend retorna errores de validaci√≥n (422), capturar en el provider y mostrarlos en el formulario (por ejemplo, usando `validator` de cada campo con mensajes del provider, o un widget de texto rojo debajo del campo).
  - Tras una creaci√≥n/edici√≥n exitosa, navegar de regreso: si es nueva publicaci√≥n, puede volver al Marketplace o directamente al detalle de la publicaci√≥n creada; si es edici√≥n, volver al detalle actualizado.
- **Pantalla Mi Perfil:**
  - Mostrar la informaci√≥n del usuario actual (desde `AuthProvider.currentUser`): foto de perfil (CircleAvatar), nombre, ubicaci√≥n, email/tel√©fono (si se quiere mostrar en perfil privado), bio, rating promedio y n√∫mero de calificaciones, estado verificado (insignia verificada si `isVerified=true`).
  - Bot√≥n **Editar Perfil**: navega a una pantalla o di√°logo para editar los datos de perfil (nombre, contacto, ubicaci√≥n, bio, foto). Similar a formulario de publicaci√≥n pero para User: campos b√°sicos y opci√≥n de nueva foto de perfil.
  - Secci√≥n **Mis Publicaciones**: debajo de la info del perfil, listar las publicaciones creadas por el usuario (usar `ListingProvider.listings` filtradas por ownerId o mantener un m√©todo para obtener solo las del usuario). Mostrar cada publicaci√≥n con sus m√©tricas (vistas, interesados, estado activo/vendido si aplica). Permitir entrar a detalle o editar directamente.
  - Opcional: mostrar notificaci√≥n si el usuario no est√° verificado (‚ÄúTu cuenta no est√° verificada. Completa X proceso para verificar.‚Äù) para incentivar la verificaci√≥n.
- **Pantalla Perfil de Vendedor (otro usuario):**
  - Similar a una vista de perfil pero para un vendedor ajeno: mostrar nombre comercial, ubicaci√≥n, bio, rating y verificado. No mostrar datos sensibles (email, tel√©fono).
  - Listar tambi√©n las publicaciones activas de ese vendedor (para que el comprador pueda ver m√°s ofertas del mismo). 
  - Bot√≥n **Contactar** presente (redundante con el de detalle, pero √∫til si se llega al perfil por otro medio).
- **Pantalla de Conversaciones (MessagesScreen):**
  - **Estructura:** Usar `Scaffold` con `AppBar` (t√≠tulo "Mensajes") y `body` con `ListView.builder` de conversaciones
  - **Fuente de datos:** `Consumer<ChatProvider>` para reactividad, obtener `conversations` del provider
  - **Widget por conversaci√≥n:** `ConversationCard` customizado que muestra:
    - `CircleAvatar` con foto del otro participante (o inicial si no tiene foto)
    - Nombre del contacto en negrita (usar `TextStyle(fontWeight: FontWeight.bold)`)
    - Snippet del √∫ltimo mensaje (m√°x 50 caracteres con ellipsis)
    - Timestamp relativo usando `timeago` package ("hace 5 min", "ayer", etc.)
    - Badge circular rojo con n√∫mero de no le√≠dos si `conversation.unreadCount > 0`
    - Indicador verde peque√±o si el otro usuario est√° online (`isOnline`)
    - Icono de verificado (‚úì) si el contacto tiene `isVerified=true`
  - **Interacciones:**
    - Al entrar a la pantalla: `ChatProvider.loadConversations()` en `initState()`
    - Pull-to-refresh: `RefreshIndicator` que llama `loadConversations()` nuevamente
    - Tap en conversaci√≥n: navega a `ChatScreen` con `Navigator.push()` pasando `conversationId`
    - Swipe-to-delete: usar `Dismissible` para eliminar conversaci√≥n (con confirmaci√≥n)
  - **Estados especiales:**
    - Loading: `CircularProgressIndicator` centrado si `isLoading=true`
    - Empty: Widget centrado con icono de chat vac√≠o y mensaje "No tienes conversaciones a√∫n"
    - Error: `SnackBar` con mensaje de error si falla la carga
  - **Badge en BottomNavigationBar:** Mostrar badge rojo con `unreadCount` total en el √≠cono de mensajes
  
- **Pantalla de Chat 1:1 (ChatScreen):**
  - **AppBar personalizado:**
    - Leading: bot√≥n back
    - Title: Row con avatar peque√±o + nombre del contacto + indicador online/offline
    - Subtitle: Estado de conexi√≥n WebSocket ("Conectado", "Reconectando...", "Sin conexi√≥n")
    - Actions: IconButton de opciones (bloquear, eliminar conversaci√≥n)
  - **Body - Lista de mensajes:**
    - `ListView.builder` con `reverse: true` (mensajes m√°s recientes abajo)
    - Cada mensaje usa widget `MessageBubble`:
      - Mensajes enviados: alineados a la derecha, color `theme.colorScheme.primaryContainer`
      - Mensajes recibidos: alineados a la izquierda, color `theme.colorScheme.surfaceVariant`
      - Contenido del mensaje en `Text` con manejo de multiline
      - Timestamp peque√±o debajo (formato "12:34 PM")
      - Estados visuales:
        - "Enviando": Spinner peque√±o gris
        - "Enviado": Check gris (‚úì)
        - "Entregado": Doble check gris (‚úì‚úì)
        - "Le√≠do": Doble check azul (‚úì‚úì)
        - "Fallido": Icono de error rojo con bot√≥n "Reintentar"
    - Auto-scroll al √∫ltimo mensaje cuando se env√≠a o recibe mensaje nuevo
    - Separador de fecha entre mensajes de d√≠as diferentes
  - **Typing Indicator:**
    - Widget `TypingIndicator` que aparece sobre el input cuando el otro usuario est√° escribiendo
    - Animaci√≥n de 3 puntos rebotando
    - Texto: "Usuario est√° escribiendo..."
  - **Input de mensaje (parte inferior):**
    - `Row` con `TextField` expandido y `IconButton` de enviar
    - TextField con:
      - Placeholder: "Escribe un mensaje..."
      - `maxLines: null` para permitir multiline (hasta 5 l√≠neas)
      - `textCapitalization: TextCapitalization.sentences`
      - `onChanged`: Detectar escritura y enviar evento de typing v√≠a WebSocket cada 3 segundos
    - Bot√≥n enviar:
      - Deshabilitado si texto vac√≠o o `isSending=true`
      - Al presionar: `ChatProvider.sendMessage(convId, text)` y limpiar TextField
      - Mostrar spinner mientras `isSending=true`
  - **Indicador de estado de conexi√≥n:**
    - Banner peque√±o arriba si `connectionState != connected`
    - "üî¥ Sin conexi√≥n - Los mensajes se enviar√°n cuando reconectes"
    - "üü° Reconectando..."
    - Desaparece autom√°ticamente cuando reconecta
  - **WebSocket en tiempo real:**
    - Al entrar a la pantalla: `WebSocketService` ya debe estar conectado (desde `ChatProvider.init()`)
    - Escuchar evento `onMessage`: si el mensaje es de esta conversaci√≥n, agregarlo al ListView
    - Escuchar evento `onTyping`: mostrar/ocultar `TypingIndicator`
    - Escuchar evento `onConnectionChange`: actualizar indicador de conexi√≥n
  - **Marcar como le√≠do:**
    - Cuando usuario entra a ChatScreen, llamar `ChatProvider.markAsRead(convId)` en `initState()`
    - Esto actualiza backend y decrementa `unreadCount` local
  - **Navegaci√≥n desde ProductDetail:**
    - Bot√≥n "Contactar Vendedor" en `ProductDetailScreen`
    - Al presionar: `ChatProvider.openConversation(sellerId, productId: product.id)`
    - Navega a `ChatScreen` con la conversaci√≥n creada/abierta
    - El primer mensaje puede incluir contexto del producto: "Hola, me interesa [Nombre del producto]"
- **Pantallas de Autenticaci√≥n:**
  - **LoginScreen:** campos para email y contrase√±a, con validaci√≥n b√°sica (no vac√≠o, formato email). Bot√≥n "Iniciar Sesi√≥n" que al presionar llama `AuthProvider.login(email, pass)`. Mostrar indicador de carga durante autenticaci√≥n. Si error (credenciales inv√°lidas), mostrar mensaje ("Email o contrase√±a incorrecta").
  - **RegisterScreen:** campos para nombre, email, tel√©fono, contrase√±a y confirmaci√≥n. Validar formatos (email v√°lido, tel√©fono quiz√°s opcional pero formato num√©rico, contrase√±a m√≠nima 6 caracteres y coincide con confirmaci√≥n). Bot√≥n "Registrarse" llama `AuthProvider.register(datos)` y luego inicia sesi√≥n autom√°tica o indica √©xito.
  - Tras login o registro exitoso, navegar a la pantalla principal (MarketplaceScreen). Mantener la sesi√≥n guardando token en SecureStorage y cargando datos de usuario.
  - Considerar un SplashScreen inicial que verifique si ya hay un token v√°lido al abrir la app: 
    - Si s√≠, saltar login (ir directo a home tras cargar perfil mediante AuthService.getProfile).
    - Si no, mostrar pantallas de bienvenida/login.

## Manejo de Errores y Validaciones en la UI
- Dar feedback claro al usuario en caso de errores:
  - Si el backend devuelve error de validaci√≥n (422) con detalles, parsear los mensajes y mostrarlos junto a los campos correspondientes en formularios (usando `FormField.errorText` o widgets de texto de error).
  - Si devuelve error de autenticaci√≥n (401 no autorizado), redirigir al login (por ejemplo, si el token expir√≥, asegurar que las pr√≥ximas llamadas AuthService fallen y triggereen logout).
  - Errores generales (500 o desconocidos): mostrar un mensaje gen√©rico mediante un `SnackBar` o `AlertDialog` ("Ocurri√≥ un error, int√©ntalo m√°s tarde") para no dejar al usuario sin retroalimentaci√≥n.
- Validar en el frontend antes de enviar para mejorar UX: por ejemplo, campos obligatorios marcados con `*`, y usar validadores en `TextFormField` para evitar llamadas innecesarias al backend. Sin embargo, siempre manejar tambi√©n la respuesta de error del backend en caso de que pase una validaci√≥n del lado cliente.
- Manejar estados de carga con indicaciones visuales:
  - Mostrar **loaders** (ej. `CircularProgressIndicator`) mientras se cargan datos iniciales de una pantalla. Por ejemplo, MarketplaceScreen muestra un spinner central si `ListingProvider.isLoading` y la lista vac√≠a.
  - Deshabilitar botones mientras se procesa una acci√≥n: ej. bot√≥n "Guardar" del formulario de publicaci√≥n se desactiva durante el env√≠o para prevenir env√≠os duplicados, mostrando quiz√° un spinner peque√±o en el propio bot√≥n.
  - Para acciones r√°pidas (like/unlike favorito), retroalimentar con cambios inmediatos en el icono, pero confirmar el estado real seg√∫n la respuesta del backend (y revertir si fall√≥).
- Implementar estados vac√≠os y mensajes informativos:
  - Ej.: Si `ListingProvider.listings` est√° vac√≠o tras cargar, mostrar texto "No se encontraron publicaciones" (quiz√° debido a filtros activos o sin datos en la plataforma).
  - En la pantalla de chats, si no hay conversaciones: mostrar un mensaje "No tienes mensajes a√∫n. ¬°Empieza a contactar vendedores desde una publicaci√≥n!".
  - Estos mensajes mejoran la UX y gu√≠an al usuario sobre qu√© hacer.

## Responsabilidades Cruzadas y Sincronizaci√≥n con Backend
- El frontend depende del backend para la veracidad de datos. Siempre que la app realice una acci√≥n (crear, editar, eliminar), esperar la respuesta confirmada del servidor antes de actualizar la UI definitivamente:
  - Ej.: al eliminar una publicaci√≥n, no quitarla de la lista inmediatamente al hacer clic, sino tras confirmar √©xito (mientras tanto, se puede optim√≠sticamente ocultar con un placeholder de "eliminando..." o deshabilitarla).
  - Si el backend responde con error (403, 404, etc.), mostrar el error y restaurar cualquier cambio optimista en la interfaz.
- Mantener los modelos de datos del frontend sincronizados con la API:
  - Si cambia la estructura JSON en el backend (ej. se renombra un campo), actualizar los m√©todos `fromJson`/`toJson` y el uso correspondiente en la app. Este archivo de reglas debe actualizarse tambi√©n si hay cambios mayores de contrato.
  - Definir constantes para la URL base de API y endpoints en un solo lugar (ej. `const String API_BASE_URL = "...";` en ApiService) para facilitar cambios de entorno (desarrollo, producci√≥n) y evitar strings duplicados.
- **Seguridad en frontend:** aunque el token previene acceso no autorizado, su manejo debe ser cuidadoso:
  - Guardar token de forma segura (usar `flutter_secure_storage` en vez de SharedPreferences para informaci√≥n sensible).
  - Nunca exponer el token ni informaci√≥n sensible en los logs de la app. 
  - Si el usuario cierra sesi√≥n, borrar token y datos personales. 
  - Implementar detecci√≥n de expiraci√≥n: si una llamada recibe 401 y el token estaba enviado, asumir expirado o inv√°lido, realizar `logout()` autom√°tico y redirigir a login.
- Optimizar la experiencia de chat con WebSockets:
  - Implementar conexi√≥n WebSocket persistente para chat en tiempo real usando `web_socket_channel`.
  - Manejar estados de conexi√≥n: conectado, desconectado, reconectando, con indicadores visuales en la UI.
  - Implementar reconexi√≥n autom√°tica con backoff exponencial en caso de p√©rdida de conexi√≥n.
  - Pausar la conexi√≥n WebSocket cuando la app est√° en segundo plano para optimizar recursos.
  - Implementar notificaciones push para mensajes recibidos cuando la app est√° en background.
- El frontend debe reflejar las reglas del backend en la UI para claridad del usuario:
  - Ej.: Si solo usuarios verificados pueden publicar (si se aplicara), la app deber√≠a informar o bloquear esa acci√≥n para usuarios no verificados con un mensaje del estilo "Tu cuenta debe ser verificada para publicar anuncios.".
  - Si un campo es obligatorio seg√∫n backend, marcarlo como obligatorio en el formulario con un asterisco y evitar permitir enviar hasta que est√© lleno.
- Pruebas manuales de integraci√≥n: el equipo frontend y backend deben realizar pruebas conjuntas de los flujos principales (registro, login, crear publicaci√≥n, navegar, chatear) en un entorno de staging. Cualquier fallo de integraci√≥n (discordancia de nombres de campos, comportamiento inesperado) debe reflejarse en ajustes tanto de c√≥digo como de estas reglas para mantener la documentaci√≥n actualizada.

## Configuraci√≥n de Google OAuth para Play Store (AAB)
- **Problema cr√≠tico:** Cuando se sube un AAB a Play Store, Google Play re-firma la aplicaci√≥n con su propia App Signing Key (ASK). El SHA-1/SHA-256 que se necesita registrar es el de la ASK de Google Play, NO el del keystore de carga.
- **Soluci√≥n implementada:** Sistema de detecci√≥n autom√°tica del tipo de compilaci√≥n en `build.gradle`:
  - **Debug APK** (`flutter run -d <device>`): Usa Client ID de Upload Key (`332023551639-bbhv3lmlbgeu9t7oap48k006m7uf0lkh.apps.googleusercontent.com`)
  - **Release APK Local** (`flutter run -d <device> --release`): Usa Client ID de Upload Key
  - **AAB Play Store** (`flutter build appbundle --release`): Usa Client ID de Play Store ASK (`332023551639-840baceq4uf1n93d6rc65svha1o0434o.apps.googleusercontent.com`)
- **Implementaci√≥n en build.gradle:**
  - El `buildType.release` detecta autom√°ticamente si se est√° compilando un bundle (AAB) o un assemble (APK) usando `gradle.startParameter.taskNames.any { it.contains('bundle') }`
  - Se configuran `manifestPlaceholders` din√°micamente seg√∫n el tipo de compilaci√≥n
  - El `AndroidManifest.xml` usa `${googleOauthClientId}` como placeholder
- **Configuraci√≥n requerida en consolas:**
  - **Google Cloud Console:** Ambos SHA-1 deben estar registrados en el mismo OAuth Client ID (Upload Key SHA-1 y Play Store ASK SHA-1)
  - **Firebase Console:** Ambos SHA-1 y SHA-256 deben estar agregados en la configuraci√≥n de la app Android, y se debe descargar un nuevo `google-services.json` que incluya ambos OAuth Client IDs
  - **Google Play Console:** Obtener SHA-1/SHA-256 de la App Signing Key desde "Integridad de la app" (App Integrity)
- **Versioning:** El `versionCode` y `versionName` se leen autom√°ticamente desde `pubspec.yaml` usando `flutter.versionCode` y `flutter.versionName` en `build.gradle`. Siempre incrementar el `versionCode` en `pubspec.yaml` antes de compilar un nuevo AAB para Play Store.

## Inteligencia Artificial y Anal√≠tica IA Insights
- Se a√±ade un cuarto bot√≥n en el `AppBar` de `ProfileScreen` para abrir la secci√≥n `IA Insights`. Mantener consistencia visual y estados activos como los dem√°s botones.
- La secci√≥n `IA Insights` debe consumir m√©tricas centralizadas expuestas por el backend. Al dise√±ar providers y servicios:
  - `IAInsightsProvider` gestionar√° estados de carga, errores y resultados separados por rol (free, premium, admin).
  - Las respuestas del backend deben incluir m√©tricas crudas y res√∫menes generados por IA cuando est√©n disponibles.
- **Segmentaci√≥n por rol:**
  - `Free`: mostrar KPIs b√°sicos (vistas, favoritos, mensajes) y un √∫nico insight en lenguaje natural. Incluir llamado a la acci√≥n para actualizar a Premium.
  - `Premium`: habilitar filtros por fecha, comparativas contra el promedio del marketplace, proyecciones y recomendaciones accionables.
  - `Admin`: vista global con m√©tricas agregadas por regi√≥n/categor√≠a, detecci√≥n de anomal√≠as y alertas operativas.
- Al integrar GPT/Gemini/DeepSeek:
  - Encapsular la l√≥gica de prompts en un servicio (`IAInsightsService`) para facilitar el cambio de proveedor.
  - Cachear resultados recientes para evitar llamadas repetidas y controlar costos.
  - Garantizar que los prompts nunca expongan datos sensibles (IDs internos, tokens).
- UI recomendada para `IA Insights`:
  - Tarjeta de resumen r√°pido (highlights de la semana).
  - Lista de recomendaciones priorizadas.
  - Historial de acciones sugeridas (mostrar si fueron marcadas como completadas).
  - Filtros de rango de fechas (d√≠a, semana, mes, hist√≥rico) y selector de hacienda/producto para premium/admin.
- Definir un inventario de m√©tricas recolectadas (vistas por publicaci√≥n, clics, contactos abiertos, rating, estado de anuncios, etc.) antes de implementar la pantalla. Documentar cada m√©trica en el backend y sincronizar naming con el frontend.
- Actualizar esta gu√≠a y el README cuando se agreguen nuevas capacidades (ej. integraciones externas, nuevas recomendaciones).

## Especificaci√≥n de UI del Demo (HTML)
- Navegaci√≥n inferior: Mercado, Favoritos, Publicar, Mensajes (con badge de no le√≠dos), Perfil.
- Vistas: `marketplace`, `detail`, `create`, `profile`, `editProfile`, `favorites`, `dashboard`, `myListings`, `messages`, `chat`, `marketPulse`, `admin*`, `termsAndConditions`.
- Marketplace: b√∫squeda, filtro por tipo (`all|lechero|engorde|padrote`), filtro por ubicaci√≥n, secci√≥n Destacadas y Recientes.
- Detalle: miniaturas con selecci√≥n, favorito, reporte, registro del animal (con/sin certificado), vendedor con insignia de verificado, editar/eliminar si es due√±o, comentarios con estrellas (1‚Äì5) y rec√°lculo de rating promedio del vendedor.
- Crear/Editar: hasta 5 fotos (primera = portada), validaci√≥n de certificado si `con-registro`, campos tipo/raza/edad/cantidad/ubicaci√≥n/descr., toggle Destacado.
- Perfil: avatar, nombre comercial, full name, bio, rating, verificado, fecha de alta, contacto y ubicaci√≥n; listado de publicaciones del usuario; secci√≥n "Legal" con acceso a T√©rminos y Condiciones y Pol√≠tica de Privacidad.
- Favoritos: rejilla de publicaciones marcadas.
- Dashboard/Mis publicaciones: m√©tricas (publicaciones, vistas, favoritos) y lista editable.
- Mensajes/Chat: conversaciones con snippet del √∫ltimo mensaje; chat 1:1 con input; al entrar a `messages` se limpian no le√≠dos.
- T√©rminos y Condiciones: pantalla reutilizable (`TermsAndConditionsScreen`) que muestra T√©rminos de Servicio o Pol√≠tica de Privacidad seg√∫n el par√°metro `type`. Accesible desde `SignInScreen` (links clickeables) y desde `ProfileScreen` (secci√≥n Legal).
- MarketPulse: genera resumen (mock) con tendencias por tipo/ubicaci√≥n.
- Admin (mock): dashboard, publicaciones, usuarios, actividad, soporte a usuario y reportes.

### Comportamientos clave
- Bot√≥n favorito con animaci√≥n "pop" y estado.
- Modal de certificado con bloqueo de scroll y cierre por overlay o bot√≥n.
- L√≠mite 5 im√°genes y ocultar caja de subida al alcanzar l√≠mite.
- Chips de filtro con estado activo y select de ubicaci√≥n.
- Badge de no le√≠dos en nav y limpieza al abrir `messages`.
- Links de T√©rminos y Condiciones en pantalla de login son clickeables y navegan a `TermsAndConditionsScreen`.

## Sistema de Colores y Temas

### Paleta de Colores - Modo Claro
```css
/* Variables CSS para Flutter (usar en corral_x_theme.dart) */
const Color primaryColor = Color(0xFF386A20);                    // Verde principal
const Color onPrimaryColor = Color(0xFFFFFFFF);                 // Blanco sobre verde
const Color primaryContainerColor = Color(0xFFB7F399);          // Verde claro contenedor
const Color onPrimaryContainerColor = Color(0xFF082100);       // Verde oscuro sobre contenedor
const Color secondaryColor = Color(0xFF55624C);                 // Verde secundario
const Color onSecondaryColor = Color(0xFFFFFFFF);               // Blanco sobre secundario
const Color secondaryContainerColor = Color(0xFFD9E7CA);        // Verde claro secundario
const Color onSecondaryContainerColor = Color(0xFF131F0D);     // Verde oscuro sobre secundario
const Color errorColor = Color(0xFFBA1A1A);                     // Rojo de error
const Color onErrorColor = Color(0xFFFFFFFF);                   // Blanco sobre error
const Color backgroundColor = Color(0xFFFCFDF7);                // Fondo principal (crema)
const Color onBackgroundColor = Color(0xFF1A1C18);              // Texto sobre fondo
const Color surfaceColor = Color(0xFFFCFDF7);                   // Superficie principal
const Color onSurfaceColor = Color(0xFF1A1C18);                 // Texto sobre superficie
const Color surfaceVariantColor = Color(0xFFE0E4D7);           // Variante de superficie
const Color onSurfaceVariantColor = Color(0xFF43483E);          // Texto sobre variante
const Color outlineColor = Color(0xFF74796D);                   // Color de borde/outline
const Color surfaceContainerHighColor = Color(0xFFE9E9E2);     // Contenedor alto
const Color surfaceContainerLowColor = Color(0xFFF4F4ED);      // Contenedor bajo
```

### Paleta de Colores - Modo Oscuro
```css
/* Variables CSS para Flutter (usar en corral_x_theme.dart) */
const Color primaryColorDark = Color(0xFF9CDA7F);              // Verde claro principal
const Color onPrimaryColorDark = Color(0xFF082100);            // Verde oscuro sobre principal
const Color primaryContainerColorDark = Color(0xFF1F3314);     // Verde oscuro contenedor
const Color onPrimaryContainerColorDark = Color(0xFFB7F399);   // Verde claro sobre contenedor
const Color secondaryColorDark = Color(0xFFBCCAB0);            // Verde claro secundario
const Color onSecondaryColorDark = Color(0xFF263420);          // Verde oscuro sobre secundario
const Color secondaryContainerColorDark = Color(0xFF3A4A2F);   // Verde medio contenedor
const Color onSecondaryContainerColorDark = Color(0xFFD9E7CA); // Verde claro sobre contenedor
const Color errorColorDark = Color(0xFFFFB4AB);                // Rojo claro de error
const Color onErrorColorDark = Color(0xFF690005);              // Rojo oscuro sobre error
const Color backgroundColorDark = Color(0xFF1A1C18);           // Fondo principal (negro verdoso)
const Color onBackgroundColorDark = Color(0xFFE0E4D7);         // Texto claro sobre fondo
const Color surfaceColorDark = Color(0xFF2B2D28);              // Superficie principal
const Color onSurfaceColorDark = Color(0xFFE0E4D7);            // Texto claro sobre superficie
const Color surfaceVariantColorDark = Color(0xFF43483E);       // Variante de superficie
const Color onSurfaceVariantColorDark = Color(0xFFC4C8BB);     // Texto sobre variante
const Color outlineColorDark = Color(0xFF8E9388);              // Color de borde/outline
const Color surfaceContainerHighColorDark = Color(0xFF2F312C); // Contenedor alto
const Color surfaceContainerLowColorDark = Color(0xFF1F211C);  // Contenedor bajo
```

### Implementaci√≥n en Flutter
```dart
// En corral_x_theme.dart
class CorralXTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF386A20),
        brightness: Brightness.light,
        primary: const Color(0xFF386A20),
        onPrimary: const Color(0xFFFFFFFF),
        primaryContainer: const Color(0xFFB7F399),
        onPrimaryContainer: const Color(0xFF082100),
        secondary: const Color(0xFF55624C),
        onSecondary: const Color(0xFFFFFFFF),
        secondaryContainer: const Color(0xFFD9E7CA),
        onSecondaryContainer: const Color(0xFF131F0D),
        error: const Color(0xFFBA1A1A),
        onError: const Color(0xFFFFFFFF),
        background: const Color(0xFFFCFDF7),
        onBackground: const Color(0xFF1A1C18),
        surface: const Color(0xFFFCFDF7),
        onSurface: const Color(0xFF1A1C18),
        surfaceVariant: const Color(0xFFE0E4D7),
        onSurfaceVariant: const Color(0xFF43483E),
        outline: const Color(0xFF74796D),
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF9CDA7F),
        brightness: Brightness.dark,
        primary: const Color(0xFF9CDA7F),
        onPrimary: const Color(0xFF082100),
        primaryContainer: const Color(0xFF1F3314),
        onPrimaryContainer: const Color(0xFFB7F399),
        secondary: const Color(0xFFBCCAB0),
        onSecondary: const Color(0xFF263420),
        secondaryContainer: const Color(0xFF3A4A2F),
        onSecondaryContainer: const Color(0xFFD9E7CA),
        error: const Color(0xFFFFB4AB),
        onError: const Color(0xFF690005),
        background: const Color(0xFF1A1C18),
        onBackground: const Color(0xFFE0E4D7),
        surface: const Color(0xFF2B2D28),
        onSurface: const Color(0xFFE0E4D7),
        surfaceVariant: const Color(0xFF43483E),
        onSurfaceVariant: const Color(0xFFC4C8BB),
        outline: const Color(0xFF8E9388),
      ),
    );
  }
}
```

### Persistencia de Tema
```dart
// Usar SharedPreferences para guardar preferencia de tema
class ThemeProvider extends ChangeNotifier {
  bool _isDarkMode = false;
  bool get isDarkMode => _isDarkMode;

  Future<void> toggleTheme() async {
    _isDarkMode = !_isDarkMode;
    await SharedPreferences.getInstance().then((prefs) {
      prefs.setBool('isDarkMode', _isDarkMode);
    });
    notifyListeners();
  }

  Future<void> loadTheme() async {
    final prefs = await SharedPreferences.getInstance();
    _isDarkMode = prefs.getBool('isDarkMode') ?? false;
    notifyListeners();
  }
}
```
