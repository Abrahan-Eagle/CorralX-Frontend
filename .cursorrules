
## Frontend (Flutter) `.cursorrules`

```md
---
description: "Guía de desarrollo Frontend (Flutter) para el MVP de Corral X"
alwaysApply: true
---

## Arquitectura Modular y Convenciones (Flutter)
- Organizar el código en la carpeta `lib/` usando una arquitectura modular por features:
  - **`lib/config/`** – Configuración central (app_config.dart, auth_utils.dart, corral_x_theme.dart, user_provider.dart).
  - **`lib/shared/`** – Servicios y widgets compartidos entre módulos.
  - **`lib/auth/`** – Módulo de autenticación (screens/, services/, models/, widgets/).
  - **`lib/onboarding/`** – Módulo de onboarding (screens/, services/, models/, widgets/).
  - **`lib/products/`** – Módulo de productos/marketplace (screens/, services/, models/, widgets/).
  - **`lib/chat/`** – Módulo de chat (screens/, services/, models/, widgets/).
  - **`lib/favorites/`** – Módulo de favoritos (screens/, services/, models/, widgets/).
  - **`lib/profiles/`** – Módulo de perfiles (screens/, services/, models/, widgets/).
  - Cada módulo contiene: `models/`, `screens/`, `services/`, `widgets/` específicos de esa funcionalidad.
- Seguir convenciones de nombrado de Dart/Flutter:
  - Nombres de archivos y directorios en minúscula y con guiones bajos (snake_case), sin espacios ni mayúsculas:contentReference[oaicite:0]{index=0}.
  - Nombres de clases en PascalCase (capitalizando cada palabra, e.j. class `ListingProvider`).
  - Nombres de variables y métodos en lowerCamelCase.
  - Evitar nombres muy largos; preferir claridad y brevedad (ej. `ListingsScreen` mejor que `AllListingsListScreen`).
- Mantener una estructura limpia: una pantalla por archivo; widgets auxiliares en archivos separados si son lo suficientemente complejos. Se puede agrupar sub-componentes dentro de carpetas por pantalla (ej. `screens/listing_detail/` con `listing_detail_screen.dart` y widgets relacionados).
- Incluir comentarios y documentación en el código para facilitar la lectura por el equipo (usar `///` para documentar clases y métodos públicos).
- Usar el patrón **Provider** para gestión de estado por simplicidad en el MVP (evitar patrones más complejos como BLoC o Riverpod a menos que el equipo los prefiera).

## Servicios y Comunicación con la API
- Centralizar las llamadas HTTP en clases de servicio bajo `lib/services/`:
  - Crear un `ApiService` base que use paquetes como `http` (o `dio` si se prefiere) para manejar peticiones. Este servicio puede gestionar el token de autenticación globalmente (p.ej., adjuntar header `Authorization: Bearer <token>` a cada request tras login).
  - Servicios específicos por recurso: ej. un `ListingService` con métodos para la lógica de publicaciones: `fetchListings({filters})`, `getListingDetail(id)`, `createListing(data)`, `updateListing(id, data)`, `deleteListing(id)`. Cada método realiza la petición REST correspondiente y retorna datos procesados (decodificados a Map o convertidos a modelo).
  - **AuthService:** métodos `login(email, pass)`, `register(datos)`, `logout()` que llaman a las rutas `/api/login`, `/api/register` y gestionan el almacenamiento seguro del token (usando `flutter_secure_storage` para el JWT, por ejemplo).
  - **ChatService:** métodos para obtener conversaciones (`getConversations()` -> GET `/api/chat/conversations`), obtener mensajes de un chat (`getMessages(convId)` -> GET `/api/chat/conversations/{id}/messages`) y enviar mensaje (`sendMessage(convId, text)` -> POST `/api/chat/conversations/{id}/messages`), marcar como leído (`markAsRead(convId)` -> POST `/api/chat/conversations/{id}/read`), crear conversación (`createConversation(participantId)` -> POST `/api/chat/conversations`), eliminar conversación (`deleteConversation(convId)` -> DELETE `/api/chat/conversations/{id}`).
  - **WebSocketService:** manejo de conexión WebSocket para chat en tiempo real, incluyendo:
    - `connect()` - Establecer conexión persistente con el servidor WebSocket
    - `disconnect()` - Cerrar conexión cuando app va a background o cierra
    - `onMessage(callback)` - Escuchar mensajes entrantes en tiempo real
    - `sendMessage(message)` - Enviar mensaje a través de WebSocket
    - `onTyping(callback)` - Detectar cuando otro usuario está escribiendo
    - `reconnect()` - Reconexión automática con backoff exponencial (1s, 2s, 4s, 8s, max 30s)
    - `heartbeat()` - Keep-alive cada 30 segundos para mantener conexión
    - Manejo de estados: `connecting`, `connected`, `disconnected`, `reconnecting`, `error`
    - Cola de mensajes pendientes cuando hay pérdida temporal de conexión
    - Indicadores visuales de estado de conexión en la UI
  - **NotificationService:** integración con Firebase Cloud Messaging (FCM) para notificaciones push:
    - `initialize()` - Configurar FCM al iniciar la app
    - `requestPermission()` - Solicitar permisos de notificaciones al usuario
    - `getToken()` - Obtener device token para envío de notificaciones
    - `onMessageReceived(callback)` - Manejar notificaciones recibidas (foreground y background)
    - `showLocalNotification(title, body)` - Mostrar notificación local
    - `navigateToChat(conversationId)` - Navegar a chat específico al tocar notificación
    - `updateBadgeCount(count)` - Actualizar badge de mensajes no leídos
    - Notificaciones silenciosas cuando app está abierta, sonido/vibración cuando está cerrada
    - Deep linking para abrir conversación específica desde notificación
  - Manejar errores HTTP en estos servicios: si la respuesta tiene código de error, interpretar y lanzar excepciones o retornar valores de error para que la UI pueda reaccionar. Ej.: 401 -> lanzar error de autenticación (frontend redirige a login), 422 -> devolver lista de errores de validación para mostrarlos en el formulario.
- Parsear las respuestas JSON en modelos Dart o mapas:
  - Si se definieron clases de modelo (con factory `fromJson`), usarlas para convertir las respuestas. Ej: `Listing.fromJson(json)` por cada elemento en la lista de listings.
  - Enviar datos al backend en formato JSON con `http.post/put` y encabezado `Content-Type: application/json`. Usar `jsonEncode` en los cuerpos, asegurando que los nombres de campos coinciden con los esperados por el backend.
- Implementar un mecanismo global de autenticación:
  - Guardar el token del usuario (y posiblemente el objeto User) en un provider global (`AuthProvider`) al hacer login.
  - Adjuntar el token en **ApiService** en cada llamada (p.ej., configurar `http.Client` con un interceptor o añadir header en cada método de servicio).
  - El AuthProvider maneja verificar si hay token guardado al iniciar la app (auto-login) y la lógica de cerrar sesión (borrar token de storage, limpiar estados).
- Manejar subida de archivos/imágenes si aplica:
  - Para adjuntar foto en una publicación o actualizar avatar, usar `ImagePicker` (para obtener la imagen local) y luego `http.MultipartRequest` o métodos de `dio` para enviar la imagen al backend (ya sea a un endpoint dedicado o incluido en el payload de creación). El servicio correspondiente debe manejar la construcción de la petición multipart.
  - Asegurarse que el backend devuelva la URL o path de la imagen guardada, y actualizar el modelo (Listing o User) con ese dato para futuras solicitudes.
- Evitar lógica de negocio compleja en las pantallas: delegar a los servicios y providers. Las pantallas solo invocan métodos de provider o service, esperan los resultados (futures) y muestran feedback (spinners, mensajes de error).

## Gestión de Estado (Provider) y Flujos de Datos
- Utilizar el paquete **provider** para manejo sencillo del estado:
  - En `main.dart`, envolver la app con `MultiProvider` registrando los ChangeNotifiers necesarios: `AuthProvider`, `ListingProvider`, `ChatProvider`, etc.
  - **AuthProvider:** mantiene info del usuario actual (usuario logueado) y su token. Expone propiedades como `isAuthenticated` y `currentUser`. Maneja `login()`/`register()`/`logout()` llamando a AuthService y notificando listeners en consecuencia.
  - **ListingProvider:** maneja la lista de publicaciones y las operaciones CRUD relacionadas.
    - Tiene una lista `listings` (inicialmente vacía) y quizás `Listing? selectedListing` para detalle. 
    - Métodos: `fetchListings([filters])` llama a ListingService.fetchListings; al obtener datos, rellena `listings` y hace `notifyListeners()`. Opcionalmente recibe filtros de búsqueda y los pasa a la API.
    - `getListingDetail(id)` podría obtener detalle de una publicación (o aprovechar los datos ya cargados en `listings`). 
    - `createListing(datos)` llama ListingService.createListing; si éxito, añade la nueva publicación a `listings` y notifica. 
    - `updateListing(id, datos)` actualiza tanto vía API como localmente en la lista (reemplazando el objeto modificado).
    - `deleteListing(id)` envía DELETE a API y si éxito, remueve la publicación de `listings`.
    - También maneja filtros locales de ser necesario (aunque es preferible delegar filtrado al backend enviando query params).
  - **ChatProvider:** maneja las conversaciones y mensajes del chat con integración completa de WebSocket y notificaciones:
    - **Estado:**
      - `List<Conversation> conversations` - Lista de todas las conversaciones del usuario
      - `Map<String, List<Message>> messagesByConv` - Mensajes organizados por conversación
      - `int unreadCount` - Contador total de mensajes no leídos (para badge)
      - `bool isLoading` - Indicador de carga inicial
      - `String? errorMessage` - Mensaje de error si falla alguna operación
      - `WebSocketConnectionState connectionState` - Estado de conexión WebSocket (connecting/connected/disconnected/reconnecting)
      - `Map<String, bool> typingUsers` - Usuarios que están escribiendo en cada conversación
    - **Métodos principales:**
      - `loadConversations()` - Obtiene lista de conversaciones vía HTTP (ChatService.getConversations), ordena por fecha del último mensaje, actualiza `unreadCount` sumando no leídos de todas las conversaciones
      - `openConversation(userId, {productId})` - Crea o abre conversación existente: primero verifica si existe conversación con ese usuario (busca en `conversations`), si no existe llama a ChatService.createConversation, luego carga mensajes con `loadMessages(convId)`, marca la conversación como activa
      - `loadMessages(convId)` - Carga historial de mensajes vía HTTP (ChatService.getMessages), guarda en `messagesByConv[convId]`, auto-marca como leído si usuario entra a la pantalla de chat
      - `sendMessage(convId, text)` - Envía mensaje con feedback optimista:
        1. Agrega mensaje localmente con estado "sending" (feedback optimista)
        2. Envía a través de WebSocketService (si conectado) o ChatService (fallback HTTP)
        3. Al recibir confirmación, actualiza estado a "sent" y asigna ID real del servidor
        4. Si falla, marca mensaje con estado "failed" y botón de reintento
        5. Actualiza `lastMessage` en la conversación correspondiente
      - `markAsRead(convId)` - Marca mensajes como leídos vía HTTP (ChatService.markAsRead), actualiza contador local `unreadCount`, actualiza estado de mensajes en `messagesByConv[convId]` a "read"
      - `deleteConversation(convId)` - Elimina conversación con confirmación del usuario, llama ChatService.deleteConversation, remueve de `conversations` localmente
    - **Integración WebSocket:**
      - En `init()` del provider, conecta WebSocketService y registra callbacks
      - `WebSocketService.onMessage((message) {...})` - Al recibir mensaje nuevo: agrega a `messagesByConv`, actualiza `lastMessage` de conversación, incrementa `unreadCount` si no está en esa conversación, dispara notificación local si app en foreground
      - `WebSocketService.onTyping((convId, userId, isTyping) {...})` - Actualiza `typingUsers[convId]` para mostrar "Usuario está escribiendo..."
      - `WebSocketService.onConnectionChange((state) {...})` - Actualiza `connectionState` para mostrar indicador visual en UI
      - Si WebSocket se desconecta, mantiene cola de mensajes pendientes y los envía cuando reconecte
    - **Integración NotificationService:**
      - En `init()`, configura callback de NotificationService para manejar tap en notificación
      - `NotificationService.onNotificationTap((convId) {...})` - Navega a ChatScreen con esa conversación
      - Cuando llega mensaje nuevo y usuario NO está en esa conversación, trigger notificación push
  - Los providers deben notificar a la UI para refrescar: usar `notifyListeners()` tras cambios. En la UI, usar `Consumer<...>` o `context.watch()` para reconstruir widgets reactivos cuando cambie el estado.
- Manejar estados de carga y error en los providers:
  - Por ejemplo, `ListingProvider` puede tener `bool isLoading` mientras carga publicaciones, y `String? errorMessage` si falla la carga. La UI (MarketplaceScreen) debe revisar estos para mostrar un `CircularProgressIndicator` cuando `isLoading=true` o un mensaje de error si `errorMessage != null`.
  - Similar para operaciones de envío: se puede tener `isSubmitting` en formularios (evita doble submit) y `validationErrors` para mostrar errores específicos de campos.
  - `ChatProvider` podría tener indicadores `isSending` para deshabilitar el campo de texto mientras se envía un mensaje, `isConnected` para mostrar el estado de la conexión WebSocket, y manejar una cola de mensajes pendientes si se quiere extender.

## Diseño de Pantallas y Navegación
- Implementar una navegación acorde a los flujos principales (se puede usar `Navigator.push`/`pop` o rutas nombradas con `onGenerateRoute`). Una barra de navegación inferior puede facilitar el acceso a secciones: Marketplace, Chats, Perfil, etc.
- **Pantalla Marketplace (Listado Principal):**
  - Muestra la lista de publicaciones en venta utilizando `ListingProvider.listings`. Usar un `ListView.builder` con un widget personalizado (`ListingCard`) para cada item, mostrando foto principal, tipo/raza, ubicación y posiblemente precio o edad.
  - En la parte superior, incluir barra de búsqueda y filtros (por raza, tipo, ubicación). Al aplicar filtros, llamar `fetchListings` con parámetros o filtrar la lista existente y notificar.
  - Implementar pull-to-refresh (usando `RefreshIndicator`) que dispare `fetchListings()` nuevamente desde el backend.
  - Al tocar una publicación, navegar a la pantalla de detalle de publicación (pasando el ID o el objeto Listing).
- **Pantalla Detalle de Publicación:**
  - Muestra la información completa de la publicación seleccionada: varias imágenes (Carousel o PageView), descripción extensa, detalles (edad, cantidad, ubicación específica, fecha publicación), y datos del vendedor (nombre comercial, ubicación general, rating, verificado con insignia).
  - Botones contextuales:
    - **Contactar / Mensaje:** visible para usuarios que no son dueños. Al pulsar, iniciar o abrir chat con el vendedor: llamar a `ChatProvider.openConversation(sellerId)` (posiblemente pasando también listingId para contexto inicial) y navegar a ChatScreen.
    - **Editar / Eliminar:** visibles solo si el usuario actual es el propietario de la publicación. *Editar* navega a la pantalla de formulario de publicación con los datos precargados. *Eliminar* muestra confirmación y si se acepta, llama `ListingProvider.deleteListing` y al éxito hace `Navigator.pop()` (y quizá refresca la lista).
  - Mostrar métricas: número de vistas de la publicación, cuántos usuarios la marcaron como favorita, etc., para el dueño (si el viewer es el propietario, mostrar estas estadísticas).
  - Debajo, listar comentarios/reseñas si existen, mostrando texto, autor y rating.
- **Pantalla Crear/Editar Publicación:**
  - Formulario (`Form` + `TextFormField`) con campos: tipo (DropdownButton o opciones predefinidas), raza (texto o dropdown si hay catálogo), edad (TextField numérico), cantidad, descripción (multilínea), ubicación (ej. Dropdown de estados o campo de texto autocompletable), y carga de imagen (botón para seleccionar foto de la galería/cámara).
  - Validar localmente campos obligatorios y formatos (no textos vacíos, números > 0 en edad/cantidad). Utilizar validadores en los `TextFormField` para feedback inmediato.
  - Botón **Guardar**: al presionar, llamar `ListingProvider.createListing` o `updateListing` según modo. Manejar estado de envío (`isSubmitting=true` para mostrar spinner sobre el botón).
  - Si el backend retorna errores de validación (422), capturar en el provider y mostrarlos en el formulario (por ejemplo, usando `validator` de cada campo con mensajes del provider, o un widget de texto rojo debajo del campo).
  - Tras una creación/edición exitosa, navegar de regreso: si es nueva publicación, puede volver al Marketplace o directamente al detalle de la publicación creada; si es edición, volver al detalle actualizado.
- **Pantalla Mi Perfil:**
  - Mostrar la información del usuario actual (desde `AuthProvider.currentUser`): foto de perfil (CircleAvatar), nombre, ubicación, email/teléfono (si se quiere mostrar en perfil privado), bio, rating promedio y número de calificaciones, estado verificado (insignia verificada si `isVerified=true`).
  - Botón **Editar Perfil**: navega a una pantalla o diálogo para editar los datos de perfil (nombre, contacto, ubicación, bio, foto). Similar a formulario de publicación pero para User: campos básicos y opción de nueva foto de perfil.
  - Sección **Mis Publicaciones**: debajo de la info del perfil, listar las publicaciones creadas por el usuario (usar `ListingProvider.listings` filtradas por ownerId o mantener un método para obtener solo las del usuario). Mostrar cada publicación con sus métricas (vistas, interesados, estado activo/vendido si aplica). Permitir entrar a detalle o editar directamente.
  - Opcional: mostrar notificación si el usuario no está verificado (“Tu cuenta no está verificada. Completa X proceso para verificar.”) para incentivar la verificación.
- **Pantalla Perfil de Vendedor (otro usuario):**
  - Similar a una vista de perfil pero para un vendedor ajeno: mostrar nombre comercial, ubicación, bio, rating y verificado. No mostrar datos sensibles (email, teléfono).
  - Listar también las publicaciones activas de ese vendedor (para que el comprador pueda ver más ofertas del mismo). 
  - Botón **Contactar** presente (redundante con el de detalle, pero útil si se llega al perfil por otro medio).
- **Pantalla de Conversaciones (MessagesScreen):**
  - **Estructura:** Usar `Scaffold` con `AppBar` (título "Mensajes") y `body` con `ListView.builder` de conversaciones
  - **Fuente de datos:** `Consumer<ChatProvider>` para reactividad, obtener `conversations` del provider
  - **Widget por conversación:** `ConversationCard` customizado que muestra:
    - `CircleAvatar` con foto del otro participante (o inicial si no tiene foto)
    - Nombre del contacto en negrita (usar `TextStyle(fontWeight: FontWeight.bold)`)
    - Snippet del último mensaje (máx 50 caracteres con ellipsis)
    - Timestamp relativo usando `timeago` package ("hace 5 min", "ayer", etc.)
    - Badge circular rojo con número de no leídos si `conversation.unreadCount > 0`
    - Indicador verde pequeño si el otro usuario está online (`isOnline`)
    - Icono de verificado (✓) si el contacto tiene `isVerified=true`
  - **Interacciones:**
    - Al entrar a la pantalla: `ChatProvider.loadConversations()` en `initState()`
    - Pull-to-refresh: `RefreshIndicator` que llama `loadConversations()` nuevamente
    - Tap en conversación: navega a `ChatScreen` con `Navigator.push()` pasando `conversationId`
    - Swipe-to-delete: usar `Dismissible` para eliminar conversación (con confirmación)
  - **Estados especiales:**
    - Loading: `CircularProgressIndicator` centrado si `isLoading=true`
    - Empty: Widget centrado con icono de chat vacío y mensaje "No tienes conversaciones aún"
    - Error: `SnackBar` con mensaje de error si falla la carga
  - **Badge en BottomNavigationBar:** Mostrar badge rojo con `unreadCount` total en el ícono de mensajes
  
- **Pantalla de Chat 1:1 (ChatScreen):**
  - **AppBar personalizado:**
    - Leading: botón back
    - Title: Row con avatar pequeño + nombre del contacto + indicador online/offline
    - Subtitle: Estado de conexión WebSocket ("Conectado", "Reconectando...", "Sin conexión")
    - Actions: IconButton de opciones (bloquear, eliminar conversación)
  - **Body - Lista de mensajes:**
    - `ListView.builder` con `reverse: true` (mensajes más recientes abajo)
    - Cada mensaje usa widget `MessageBubble`:
      - Mensajes enviados: alineados a la derecha, color `theme.colorScheme.primaryContainer`
      - Mensajes recibidos: alineados a la izquierda, color `theme.colorScheme.surfaceVariant`
      - Contenido del mensaje en `Text` con manejo de multiline
      - Timestamp pequeño debajo (formato "12:34 PM")
      - Estados visuales:
        - "Enviando": Spinner pequeño gris
        - "Enviado": Check gris (✓)
        - "Entregado": Doble check gris (✓✓)
        - "Leído": Doble check azul (✓✓)
        - "Fallido": Icono de error rojo con botón "Reintentar"
    - Auto-scroll al último mensaje cuando se envía o recibe mensaje nuevo
    - Separador de fecha entre mensajes de días diferentes
  - **Typing Indicator:**
    - Widget `TypingIndicator` que aparece sobre el input cuando el otro usuario está escribiendo
    - Animación de 3 puntos rebotando
    - Texto: "Usuario está escribiendo..."
  - **Input de mensaje (parte inferior):**
    - `Row` con `TextField` expandido y `IconButton` de enviar
    - TextField con:
      - Placeholder: "Escribe un mensaje..."
      - `maxLines: null` para permitir multiline (hasta 5 líneas)
      - `textCapitalization: TextCapitalization.sentences`
      - `onChanged`: Detectar escritura y enviar evento de typing vía WebSocket cada 3 segundos
    - Botón enviar:
      - Deshabilitado si texto vacío o `isSending=true`
      - Al presionar: `ChatProvider.sendMessage(convId, text)` y limpiar TextField
      - Mostrar spinner mientras `isSending=true`
  - **Indicador de estado de conexión:**
    - Banner pequeño arriba si `connectionState != connected`
    - "🔴 Sin conexión - Los mensajes se enviarán cuando reconectes"
    - "🟡 Reconectando..."
    - Desaparece automáticamente cuando reconecta
  - **WebSocket en tiempo real:**
    - Al entrar a la pantalla: `WebSocketService` ya debe estar conectado (desde `ChatProvider.init()`)
    - Escuchar evento `onMessage`: si el mensaje es de esta conversación, agregarlo al ListView
    - Escuchar evento `onTyping`: mostrar/ocultar `TypingIndicator`
    - Escuchar evento `onConnectionChange`: actualizar indicador de conexión
  - **Marcar como leído:**
    - Cuando usuario entra a ChatScreen, llamar `ChatProvider.markAsRead(convId)` en `initState()`
    - Esto actualiza backend y decrementa `unreadCount` local
  - **Navegación desde ProductDetail:**
    - Botón "Contactar Vendedor" en `ProductDetailScreen`
    - Al presionar: `ChatProvider.openConversation(sellerId, productId: product.id)`
    - Navega a `ChatScreen` con la conversación creada/abierta
    - El primer mensaje puede incluir contexto del producto: "Hola, me interesa [Nombre del producto]"
- **Pantallas de Autenticación:**
  - **LoginScreen:** campos para email y contraseña, con validación básica (no vacío, formato email). Botón "Iniciar Sesión" que al presionar llama `AuthProvider.login(email, pass)`. Mostrar indicador de carga durante autenticación. Si error (credenciales inválidas), mostrar mensaje ("Email o contraseña incorrecta").
  - **RegisterScreen:** campos para nombre, email, teléfono, contraseña y confirmación. Validar formatos (email válido, teléfono quizás opcional pero formato numérico, contraseña mínima 6 caracteres y coincide con confirmación). Botón "Registrarse" llama `AuthProvider.register(datos)` y luego inicia sesión automática o indica éxito.
  - Tras login o registro exitoso, navegar a la pantalla principal (MarketplaceScreen). Mantener la sesión guardando token en SecureStorage y cargando datos de usuario.
  - Considerar un SplashScreen inicial que verifique si ya hay un token válido al abrir la app: 
    - Si sí, saltar login (ir directo a home tras cargar perfil mediante AuthService.getProfile).
    - Si no, mostrar pantallas de bienvenida/login.

## Manejo de Errores y Validaciones en la UI
- Dar feedback claro al usuario en caso de errores:
  - Si el backend devuelve error de validación (422) con detalles, parsear los mensajes y mostrarlos junto a los campos correspondientes en formularios (usando `FormField.errorText` o widgets de texto de error).
  - Si devuelve error de autenticación (401 no autorizado), redirigir al login (por ejemplo, si el token expiró, asegurar que las próximas llamadas AuthService fallen y triggereen logout).
  - Errores generales (500 o desconocidos): mostrar un mensaje genérico mediante un `SnackBar` o `AlertDialog` ("Ocurrió un error, inténtalo más tarde") para no dejar al usuario sin retroalimentación.
- Validar en el frontend antes de enviar para mejorar UX: por ejemplo, campos obligatorios marcados con `*`, y usar validadores en `TextFormField` para evitar llamadas innecesarias al backend. Sin embargo, siempre manejar también la respuesta de error del backend en caso de que pase una validación del lado cliente.
- Manejar estados de carga con indicaciones visuales:
  - Mostrar **loaders** (ej. `CircularProgressIndicator`) mientras se cargan datos iniciales de una pantalla. Por ejemplo, MarketplaceScreen muestra un spinner central si `ListingProvider.isLoading` y la lista vacía.
  - Deshabilitar botones mientras se procesa una acción: ej. botón "Guardar" del formulario de publicación se desactiva durante el envío para prevenir envíos duplicados, mostrando quizá un spinner pequeño en el propio botón.
  - Para acciones rápidas (like/unlike favorito), retroalimentar con cambios inmediatos en el icono, pero confirmar el estado real según la respuesta del backend (y revertir si falló).
- Implementar estados vacíos y mensajes informativos:
  - Ej.: Si `ListingProvider.listings` está vacío tras cargar, mostrar texto "No se encontraron publicaciones" (quizá debido a filtros activos o sin datos en la plataforma).
  - En la pantalla de chats, si no hay conversaciones: mostrar un mensaje "No tienes mensajes aún. ¡Empieza a contactar vendedores desde una publicación!".
  - Estos mensajes mejoran la UX y guían al usuario sobre qué hacer.

## Responsabilidades Cruzadas y Sincronización con Backend
- El frontend depende del backend para la veracidad de datos. Siempre que la app realice una acción (crear, editar, eliminar), esperar la respuesta confirmada del servidor antes de actualizar la UI definitivamente:
  - Ej.: al eliminar una publicación, no quitarla de la lista inmediatamente al hacer clic, sino tras confirmar éxito (mientras tanto, se puede optimísticamente ocultar con un placeholder de "eliminando..." o deshabilitarla).
  - Si el backend responde con error (403, 404, etc.), mostrar el error y restaurar cualquier cambio optimista en la interfaz.
- Mantener los modelos de datos del frontend sincronizados con la API:
  - Si cambia la estructura JSON en el backend (ej. se renombra un campo), actualizar los métodos `fromJson`/`toJson` y el uso correspondiente en la app. Este archivo de reglas debe actualizarse también si hay cambios mayores de contrato.
  - Definir constantes para la URL base de API y endpoints en un solo lugar (ej. `const String API_BASE_URL = "...";` en ApiService) para facilitar cambios de entorno (desarrollo, producción) y evitar strings duplicados.
- **Seguridad en frontend:** aunque el token previene acceso no autorizado, su manejo debe ser cuidadoso:
  - Guardar token de forma segura (usar `flutter_secure_storage` en vez de SharedPreferences para información sensible).
  - Nunca exponer el token ni información sensible en los logs de la app. 
  - Si el usuario cierra sesión, borrar token y datos personales. 
  - Implementar detección de expiración: si una llamada recibe 401 y el token estaba enviado, asumir expirado o inválido, realizar `logout()` automático y redirigir a login.
- Optimizar la experiencia de chat con WebSockets:
  - Implementar conexión WebSocket persistente para chat en tiempo real usando `web_socket_channel`.
  - Manejar estados de conexión: conectado, desconectado, reconectando, con indicadores visuales en la UI.
  - Implementar reconexión automática con backoff exponencial en caso de pérdida de conexión.
  - Pausar la conexión WebSocket cuando la app está en segundo plano para optimizar recursos.
  - Implementar notificaciones push para mensajes recibidos cuando la app está en background.
- El frontend debe reflejar las reglas del backend en la UI para claridad del usuario:
  - Ej.: Si solo usuarios verificados pueden publicar (si se aplicara), la app debería informar o bloquear esa acción para usuarios no verificados con un mensaje del estilo "Tu cuenta debe ser verificada para publicar anuncios.".
  - Si un campo es obligatorio según backend, marcarlo como obligatorio en el formulario con un asterisco y evitar permitir enviar hasta que esté lleno.
- Pruebas manuales de integración: el equipo frontend y backend deben realizar pruebas conjuntas de los flujos principales (registro, login, crear publicación, navegar, chatear) en un entorno de staging. Cualquier fallo de integración (discordancia de nombres de campos, comportamiento inesperado) debe reflejarse en ajustes tanto de código como de estas reglas para mantener la documentación actualizada.

## Especificación de UI del Demo (HTML)
- Navegación inferior: Mercado, Favoritos, Publicar, Mensajes (con badge de no leídos), Perfil.
- Vistas: `marketplace`, `detail`, `create`, `profile`, `editProfile`, `favorites`, `dashboard`, `myListings`, `messages`, `chat`, `marketPulse`, `admin*`.
- Marketplace: búsqueda, filtro por tipo (`all|lechero|engorde|padrote`), filtro por ubicación, sección Destacadas y Recientes.
- Detalle: miniaturas con selección, favorito, reporte, registro del animal (con/sin certificado), vendedor con insignia de verificado, editar/eliminar si es dueño, comentarios con estrellas (1–5) y recálculo de rating promedio del vendedor.
- Crear/Editar: hasta 5 fotos (primera = portada), validación de certificado si `con-registro`, campos tipo/raza/edad/cantidad/ubicación/descr., toggle Destacado.
- Perfil: avatar, nombre comercial, full name, bio, rating, verificado, fecha de alta, contacto y ubicación; listado de publicaciones del usuario.
- Favoritos: rejilla de publicaciones marcadas.
- Dashboard/Mis publicaciones: métricas (publicaciones, vistas, favoritos) y lista editable.
- Mensajes/Chat: conversaciones con snippet del último mensaje; chat 1:1 con input; al entrar a `messages` se limpian no leídos.
- MarketPulse: genera resumen (mock) con tendencias por tipo/ubicación.
- Admin (mock): dashboard, publicaciones, usuarios, actividad, soporte a usuario y reportes.

### Comportamientos clave
- Botón favorito con animación "pop" y estado.
- Modal de certificado con bloqueo de scroll y cierre por overlay o botón.
- Límite 5 imágenes y ocultar caja de subida al alcanzar límite.
- Chips de filtro con estado activo y select de ubicación.
- Badge de no leídos en nav y limpieza al abrir `messages`.

## Sistema de Colores y Temas

### Paleta de Colores - Modo Claro
```css
/* Variables CSS para Flutter (usar en corral_x_theme.dart) */
const Color primaryColor = Color(0xFF386A20);                    // Verde principal
const Color onPrimaryColor = Color(0xFFFFFFFF);                 // Blanco sobre verde
const Color primaryContainerColor = Color(0xFFB7F399);          // Verde claro contenedor
const Color onPrimaryContainerColor = Color(0xFF082100);       // Verde oscuro sobre contenedor
const Color secondaryColor = Color(0xFF55624C);                 // Verde secundario
const Color onSecondaryColor = Color(0xFFFFFFFF);               // Blanco sobre secundario
const Color secondaryContainerColor = Color(0xFFD9E7CA);        // Verde claro secundario
const Color onSecondaryContainerColor = Color(0xFF131F0D);     // Verde oscuro sobre secundario
const Color errorColor = Color(0xFFBA1A1A);                     // Rojo de error
const Color onErrorColor = Color(0xFFFFFFFF);                   // Blanco sobre error
const Color backgroundColor = Color(0xFFFCFDF7);                // Fondo principal (crema)
const Color onBackgroundColor = Color(0xFF1A1C18);              // Texto sobre fondo
const Color surfaceColor = Color(0xFFFCFDF7);                   // Superficie principal
const Color onSurfaceColor = Color(0xFF1A1C18);                 // Texto sobre superficie
const Color surfaceVariantColor = Color(0xFFE0E4D7);           // Variante de superficie
const Color onSurfaceVariantColor = Color(0xFF43483E);          // Texto sobre variante
const Color outlineColor = Color(0xFF74796D);                   // Color de borde/outline
const Color surfaceContainerHighColor = Color(0xFFE9E9E2);     // Contenedor alto
const Color surfaceContainerLowColor = Color(0xFFF4F4ED);      // Contenedor bajo
```

### Paleta de Colores - Modo Oscuro
```css
/* Variables CSS para Flutter (usar en corral_x_theme.dart) */
const Color primaryColorDark = Color(0xFF9CDA7F);              // Verde claro principal
const Color onPrimaryColorDark = Color(0xFF082100);            // Verde oscuro sobre principal
const Color primaryContainerColorDark = Color(0xFF1F3314);     // Verde oscuro contenedor
const Color onPrimaryContainerColorDark = Color(0xFFB7F399);   // Verde claro sobre contenedor
const Color secondaryColorDark = Color(0xFFBCCAB0);            // Verde claro secundario
const Color onSecondaryColorDark = Color(0xFF263420);          // Verde oscuro sobre secundario
const Color secondaryContainerColorDark = Color(0xFF3A4A2F);   // Verde medio contenedor
const Color onSecondaryContainerColorDark = Color(0xFFD9E7CA); // Verde claro sobre contenedor
const Color errorColorDark = Color(0xFFFFB4AB);                // Rojo claro de error
const Color onErrorColorDark = Color(0xFF690005);              // Rojo oscuro sobre error
const Color backgroundColorDark = Color(0xFF1A1C18);           // Fondo principal (negro verdoso)
const Color onBackgroundColorDark = Color(0xFFE0E4D7);         // Texto claro sobre fondo
const Color surfaceColorDark = Color(0xFF2B2D28);              // Superficie principal
const Color onSurfaceColorDark = Color(0xFFE0E4D7);            // Texto claro sobre superficie
const Color surfaceVariantColorDark = Color(0xFF43483E);       // Variante de superficie
const Color onSurfaceVariantColorDark = Color(0xFFC4C8BB);     // Texto sobre variante
const Color outlineColorDark = Color(0xFF8E9388);              // Color de borde/outline
const Color surfaceContainerHighColorDark = Color(0xFF2F312C); // Contenedor alto
const Color surfaceContainerLowColorDark = Color(0xFF1F211C);  // Contenedor bajo
```

### Implementación en Flutter
```dart
// En corral_x_theme.dart
class CorralXTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF386A20),
        brightness: Brightness.light,
        primary: const Color(0xFF386A20),
        onPrimary: const Color(0xFFFFFFFF),
        primaryContainer: const Color(0xFFB7F399),
        onPrimaryContainer: const Color(0xFF082100),
        secondary: const Color(0xFF55624C),
        onSecondary: const Color(0xFFFFFFFF),
        secondaryContainer: const Color(0xFFD9E7CA),
        onSecondaryContainer: const Color(0xFF131F0D),
        error: const Color(0xFFBA1A1A),
        onError: const Color(0xFFFFFFFF),
        background: const Color(0xFFFCFDF7),
        onBackground: const Color(0xFF1A1C18),
        surface: const Color(0xFFFCFDF7),
        onSurface: const Color(0xFF1A1C18),
        surfaceVariant: const Color(0xFFE0E4D7),
        onSurfaceVariant: const Color(0xFF43483E),
        outline: const Color(0xFF74796D),
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF9CDA7F),
        brightness: Brightness.dark,
        primary: const Color(0xFF9CDA7F),
        onPrimary: const Color(0xFF082100),
        primaryContainer: const Color(0xFF1F3314),
        onPrimaryContainer: const Color(0xFFB7F399),
        secondary: const Color(0xFFBCCAB0),
        onSecondary: const Color(0xFF263420),
        secondaryContainer: const Color(0xFF3A4A2F),
        onSecondaryContainer: const Color(0xFFD9E7CA),
        error: const Color(0xFFFFB4AB),
        onError: const Color(0xFF690005),
        background: const Color(0xFF1A1C18),
        onBackground: const Color(0xFFE0E4D7),
        surface: const Color(0xFF2B2D28),
        onSurface: const Color(0xFFE0E4D7),
        surfaceVariant: const Color(0xFF43483E),
        onSurfaceVariant: const Color(0xFFC4C8BB),
        outline: const Color(0xFF8E9388),
      ),
    );
  }
}
```

### Persistencia de Tema
```dart
// Usar SharedPreferences para guardar preferencia de tema
class ThemeProvider extends ChangeNotifier {
  bool _isDarkMode = false;
  bool get isDarkMode => _isDarkMode;

  Future<void> toggleTheme() async {
    _isDarkMode = !_isDarkMode;
    await SharedPreferences.getInstance().then((prefs) {
      prefs.setBool('isDarkMode', _isDarkMode);
    });
    notifyListeners();
  }

  Future<void> loadTheme() async {
    final prefs = await SharedPreferences.getInstance();
    _isDarkMode = prefs.getBool('isDarkMode') ?? false;
    notifyListeners();
  }
}
```
